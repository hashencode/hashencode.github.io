{"pages":[],"posts":[{"title":"算法基础 - 冒泡排序","text":"冒泡排序，就是将两个数进行比较，大的数向一个固定方向移动，然后大的数再与下一个数比较并移动，在数组中重复该动作，就能将当前最大的数移到一侧，然后再从数组头部开始，重复比较和移动动作，最后所有的数都会按照从小到大的顺序排列 这里有非常直观的可视化排序过程：visualgo 思路如果要从小到大排列数组里的数字 首先，对数组进行遍历，每次取两个数进行比较，如果左侧的数比右侧的大，则交换两者的位置； 然后，再次对剩余的部分数字进行循环； 实现function bubble(target){ for(let m=0; m&lt;target.length; m++){ for( let i=0; i&lt;target.length-1-m; i++ ){ if(target[i]>target[i+1]){ // 使用es6的解构赋值 [target[i],target[i+1]] = [target[i+1],target[i]]; } } } } 测试用例const testArray = [42,30,45,16,40,7,11,45,33,12,14,30,35,32,4,2]; function bubble(target){ for(let m=0; m&lt;target.length; m++){ for( let i=0; i&lt;target.length-1-m; i++ ){ if(target[i]>target[i+1]){ // 使用es6的解构赋值 [target[i],target[i+1]] = [target[i+1],target[i]]; } } } } bubble(testArray); console.log(testArray);","link":"/post/29dd3dc/"},{"title":"CSS Content 属性","text":"在伪元素中可使用 content 属性，能够实现内容的插入且内容始终只会存在于样式中，所以很适合作为反爬虫手段来使用，具体的用途主要有下列几种 插入文字文字直接赋予 content 属性 p::before { content:'A' } &lt;p>X&lt;/p> output：AX 插入符号如果要给内容加上书引号，可以使用以下方式： p::before { content:'《' } p::after { content:'》' } &lt;p>X&lt;/p> output：《X》 除此之外还可以设置quotes属性，通过open-quote或close-quote来调用，举个例子： p { quotes:'《' '》'; } p::before { content:open-quote } p::after { content:close-quote } &lt;p>X&lt;/p> output：《X》 quotes 支持传入多组字符串，各组之间是嵌套关系，举个例子： p { quotes:'《' '》' '?' '?'; } p::before { content:open-quote } p::after { content:close-quote } &lt;p>XX&lt;p>AAA&lt;/p>XX&lt;/p> output：《XX?AAA?XX》 插入图片content 直接传入url( imgPath )即可插入图片 div::before { content:url(imgPath); } 但是图片无法修改其大小，可以用伪元素+背景图片代替 div::before { content:''; background-image:url(imgPath); background-size:200px 200px; position: absolute; width:200px; height:200px; } 插入编号content 的 counter 属性能够实现项目的连续编号添加， 我们举一个树状列表的例子： &lt;ul class='outer'> &lt;li class='outer-item'> 外部项目 &lt;ul class='inner'> &lt;li class='inner-item'>内部项目&lt;/li> &lt;li class='inner-item'>内部项目&lt;/li> &lt;li class='inner-item'>内部项目&lt;/li> &lt;/ul> &lt;/li> ... &lt;/ul> 首先使用 counter-reset 初始化计数器，如果未指定初始值，则默认为0，也可通过设置第二个参数指定起始数值，初始值必须是整数。 ul { counter-reset: xcounter; } 使用然后在 content-increment 触发计数器，默认为 +1，也可以通过设置第二个参数指定累加数值。 li::before { content: counter(xcounter); /*读取当前计数器的值*/ counter-increment: xcounter; /*触发计数器的累加*/ } 这时候输出的是[查看例子]： 每当遇到 ul 时，计数器都会重置，导致二级内容并没有继承一级内容，这时就需要counters()：一个能嵌套计数的方法，他能够记住父级的值，现在用 counters替换counter（counters 还需要第二个参数用来设置拼接字符） li::before { content: counters(xcounter,'-')'.'; /*最后加上的 . 与 counters 无关*/ counter-increment: xcounter; } 这最后输出结果是这样的[查看例子]：","link":"/post/702dc888/"},{"title":"算法基础 - 二分法","text":"二分法，目的是找到目标对象的索引值，取中位数和数组的中间元素比较，如果等于中间元素，则直接返回。如果不等于则取半继续查找 实现下面的实现，默认给出的数组是从小到大依次排序的 递归实现function binarySearch({arr,target,startIndex,endIndex}){ // 如果数组的最大值小于目标值，直接返回 -1 if( arr[endIndex] &lt; target ) return -1; const midIndex = Math.floor((endIndex + startIndex)/2); // 如果中位数和目标值相等，直接返回 if( arr[midIndex] === target ){ return midIndex; }else{ // 如果中位数小于目标值，则取右侧数据 if( arr[midIndex] &lt; target ){ return binarySearch({ arr, target, startIndex: midIndex + 1, endIndex }); } else { return binarySearch({ arr, target, startIndex, endIndex: midIndex - 1 }); } } } 测试用例const testArray = [2,4,7,11,12,14,16,30,32,33,35,40,42,45]; function binarySearch({arr,target,startIndex,endIndex}){ // 如果数组的最大值小于目标值，直接返回 -1 if( arr[endIndex] &lt; target ) return -1; const midIndex = Math.floor((endIndex + startIndex)/2); // 如果中位数和目标值相等，直接返回 if( arr[midIndex] === target ){ return midIndex; }else{ // 如果中位数小于目标值，则取右侧数据 if( arr[midIndex] &lt; target ){ return binarySearch({ arr, target, startIndex: midIndex + 1, endIndex }); } else { return binarySearch({ arr, target, startIndex, endIndex: midIndex - 1 }); } } } const index = binarySearch({ arr: testArray, target: 40, startIndex: 0, endIndex: testArray.length-1 }) console.log(index)","link":"/post/addfa579/"},{"title":"CSS 动画","text":"CSS 动画 API 详解 动画属性animation 由以下属性构成： animation-name 名称 animation-delay 延迟 animation-duration 持续时间 animation-timing-function 缓动函数 animation-iteration-count 执行次数 animation-direction 动画是否反向播放 animation-fill-mode 设置CSS动画在执行之前和之后如何将样式应用于其目标 animation-play-state 控制动画的运行或暂停 动画阶段动画的阶段分为：初始状态、等待期、动画执行期、完成期 初始状态：就是没有触发动画效果时，元素原有的状态（即不含 animation 的属性） 等待期：从触发动画开始到 animation-delay 计时结束的这段时间 动画执行期：在 delay 时间结束的瞬间开始执行动画，一直持续要最后一帧 完成期：执行完最后一帧时，元素处于的状态 动画缓动函数常见函数：ease、ease-in、ease-out、ease-in-out、linear、step-start、step-end step-start 、step-endstep-start：动画立即跳转至最终状态 step-end：动画在结束时跳转至最终状态 现在假设一个方块的动画如下： @keyframes move { 0% { left: 0; } 100% { left: 100px; } } 动画持续时长为 10s，当设置缓动函数为 step-start 时，方块会立即移动到 100px 处，当设置缓动函数为 step-end 时，方块会在动画结束时移动到 100px 处，在开始到结束的过程中，都不会产生位移。 stepsstep 逐步运动，像是将丝滑的动画进行逐帧播放，其语法为：steps(number , position) 通过 number 参数讲一个运动过程平均拆分为多段， position 通过 start 或 end 值，来控制在每一段的开始还是时触发动画 当 position 的值为 start 时，是在每一段的结尾部分触发动画 当 position 的值为 end 时，是在每一段的开始部分触发动画 steps 实现 GIF 逐帧动画，假如我们有如下一张12帧的 GIF 静态图 在不使用 steps 的时候，查看效果 如果适用 steps 来进行逐帧播放，那么效果就是符合预期的，查看效果 cubic-bezier 贝塞尔函数cubic-bezier 函数定义了一个贝塞尔曲线 贝塞尔曲线曲线由四个点 P0，P1，P2 和 P3 定义。P0 和 P3 是曲线的起点和终点。P0是（0,0）并且表示初始时间和初始状态，P3是（1,1）并且表示最终时间和最终状态。 我们需要关注的是 P1 和 P2 两点的取值，而其中 X 轴的取值范围是 0 到 1，当取值超出范围时 cubic-bezier 将失效；Y 轴的取值没有规定，当然也毋须过大。 最直接的理解是，将以一条直线放在范围只有 1 的坐标轴中，并从中间拿出两个点来拉扯（X 轴的取值区间是 [0, 1]，Y 轴任意），最后形成的曲线就是动画的速度曲线。 可以通过可视化工具生成贝塞尔函数 direction 反向播放animation-direction 有以下属性： normal：动画从头开始播放 reverse：动画从最后一个关键帧开始，在第一个关键帧结束，normal 和 reverse 都相当于单向播放 alternate：动画从第一个关键帧开始，在最后一个关键帧结束，然后在最后一个关键帧开始，在第一个关键帧结束 alternate-reverse：与 alternate 相反，两者都相当于来回播放 将上面的 GIF 动图的 animation-direction 设置为 alternate，此时动图就不是从头开始重播了，查看效果 fill-modefill-mode 设置CSS动画在执行之前和之后如何将样式应用于其目标，影响的是动画的等待期和完成期的状态 fill-mode 有四个值： none：等待期和完成期的元素样式都是初始状态样式； 下面假设有一个盒子，css 样式如下： .box{ transform: translateY(0); } .box.on{ animation: move 1s; } @keyframes move{ from{transform: translateY(-50px)} to {transform: translateY(50px)} } fill-mode 为 none 时转换成的坐标轴图形： both：等待期样式为第一帧的样式，完成期保持最后一帧的样式； backwards：等待期样式为第一帧样式，完成期跳转为最初始的样式； forwards：等待期保持最初始的样式，完成期保持最后一帧的样式； iteration-countiteration-count 用于定义动画在结束前运行的次数，次数的值可以是整数，也可以是小数（例如设置值为 1.5 时，动画会执行一遍，然后再次开始，执行到一半时，动画结束），也可以是无限循环的 infinite play-stateplay-state 用于控制动画的运行和暂停，当恢复一个暂停的动画时，是从暂停的位置开始，而不是从动画序列的起点开始 play-state 有三个值： unset：不设置 running：正在运行 paused：动画暂停","link":"/post/19ff9408/"},{"title":"CSS 实现高度与宽度间的自适应","text":"在不使用 JS 的前提下实现元素高度的自适应。 当一个图片的容器未设定高度时，就会出现未加载时容器塌陷、加载过程中高度变化引起闪烁等情况。为此需要给容器一个高度，但是当宽度不固定时，一个固定的高度往往会使得图片展示变形，因此要求高度能够随着宽度的改变而改变，下面介绍的是利用 padding 撑开容器进行占位，间接实现设置容器高度的方法。 原理padding 设置为百分比时相对的是父元素的宽度，通过设置容器的 padding-top 属性将其撑开，容器的高度便能和宽度实现一定比例的自适应。 实例假如需要模仿淘宝的搜索结果页面，左侧小图是页面宽度的 30%，小图为宽度和高度相等的正方形。 首先创建一个小图的容器。 &lt;div class=\"box\" /> 小图（box）宽度为父元素的 30%，宽度和撑开的高度若要相等，则 padding-top 的值就等于 30%，至于图片的展示，可以采用 background 属性或者将&lt;img/&gt;标签设置为绝对定位的方式进行填充。 .box{ position:relative; width:30%; overflow:hidden; padding-top:30%; background:url('https://via.placeholder.com/200x200'); } 优化上述代码的缺点是：无法通过 max-height 来限制容器的最大高度。因为通过 padding 的方式实现，容器的高度始终是 0px，所以需要通过设置伪元素 padding 的方式来使容器有真正的高度。 .box{ position:relative; width:30%; overflow:hidden; } .box-fillup{ content:''; display:block; padding-bottom:30%; }","link":"/post/c6c9abf/"},{"title":"开发 - Git基础","text":"Git的名词解释和常用命令 准备秘钥## 生成公钥 ssh-keygen ## 查看公钥 cd ~/.ssh/ cat id_rsa.pub Git 名词解释区域划分git 内部分为：远程仓库（Remote）、本地仓库（Repository）、暂存区（Index）、工作区（workspace）。 下图描述了四者之间的关系： 工作区：文件目录。 暂存区： 放在 .git/index 目录下，当执行git add &lt;file&gt;命令时，数据就进入了暂存区。 暂存区的意义有三个： 简化提交 将多次的文件改动合并成一次提交，避免了频繁 commit 操作 文件快照 在执行git add &lt;file&gt;时，实际上是在暂存区创建了工作区的文件快照，与工作区是互相隔离的，想要回退到某个快照时，可从暂存区中恢复文件到工作区。 “休眠”改动 详见下述 Git 命令中的 stash 命令 本地仓库：当执行git commit命令时，暂存区所有的数据就都被提交到了本地仓库并清空。 远程仓库：当执行git push命令时，数据就被提交到了远程仓库。 HEAD打开 .git 文件夹内的 HEAD 文件可以看到类似ref: refs/heads/master的字符串，说明 HEAD 指针指向的是分支，再由分支指向 commit 对象，HEAD 指针会随着分支指针的变化而变化。下图中，切换到了 maint 分支后，HEAD 也指向了 maint 分支的最新提交。 不过 HEAD 指针不一定指向分支，他也可以直接指向 commit 对象，当使用git checkout &lt;commit&gt;命令时，HEAD 指针会处于detached HEAD（游离）状态，如下图： 游离的 HEAD 常用于定位 bug，可以回到某个提交，做出修改后可以直接使用git switch -c &lt;branch&gt;新建一个分支，这样一来，原分支没有被影响且不需要做回退的操作，又获得了一个处理好问题的新分支。 在 Git 命令中，HEAD 指针常用来做定位，例如 checkout 、reset 命令都可以使用HEAD~n作为定位参数，n 从 0 开始，HEAD~ 表示当前 commit，HEAD~1 表示前一个 commit。 Branch分支是指向 commit 对象的指针 Origin远程仓库名字 origin 与分支名字 master 一样，在 Git 中并没有任何特别的含义。 master 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用; origin 是当你运行 git clone 时默认的远程仓库名字。 Git 命令Checkoutcheckout 有两个功能： 撤销工作区的修改 使用git checkout -- &lt;file&gt;命令，可以将当前文件在工作区的修改进行撤销 用于从历史 commit 提交中恢复（所有或单个）文件到工作区和暂存区 恢复所有文件：git checkout &lt;commit&gt; 如下图，使用git checkout master~3将工作区和缓存区恢复到 commit b325c 时的状态。 恢复单个文件：git checkout &lt;commit&gt; -- &lt;file&gt; 如下图，使用git checkout HEAD~ -- readme.md 将 readme.md 文件从 commit da985 中恢复至工作区和暂存区。 Rebaserebase（变基）的用途：改变分支中一个/多个 commit 的基点。 rebase 和 merge 都用于将一个分支合并入另一个分支，但是他们在执行的结果上是有区别的，假设现在有两个分支 feature 和 master，两个分支都有新的提交，如下图所示： 现要将 main 分支的修改合并到 feature 分支上，用 merge 和 rebase 两种方式去合并这两个分支会产生不同的结果。 git merge main的执行结果： 创建了一个新的合并提交，优点是保留了完整的历史记录，缺点是经常合并分支会令提交历史变得杂乱。 git rebase main的执行结果： 为 feature 分支的每一个提交都创建了全新的副本（副本与预案提交的 id 不同），并将其移动到 main 分支的顶端，在此过程中没有产生额外的提交，能够保持提交历史的简洁，但是 rebase 命令重写了项目的历史记录，丢失了合并提交的上下文，无法看到真实的更改是何时合并到目标分支上的，所以 rebase 更适合在没有和别人协同工作的情况下使用。 Pull取回远程主机某个分支的更新，再与本地的指定分支合并 ## 拉取并合并 branch2 分支 git pull origin branch2 ## 如果当前所在的本地分支和远程分支存在映射关系，则可以直接使用简化的命令 git pull git pull是git fetch和git merge两个命令的缩写 git pull origin ## 实际上就相当于 git fetch origin branch2 git merge origin/branch2 Resetreset 用于撤销操作 撤销文件修改： git reset -- ## 将所有文件移出暂存区 git reset ## 将 hello.md 文件移出暂存区 git reset -- hello.md 撤销提交： git reset ## 撤销最后两个提交 git reset HEAD~2 ## 撤销u7hfi2提交之后的所有提交 git reset u7hfi2 修改范围 reset 有三种参数，对应了对不同范围的修改： --soft 只回退 commit，不会影响工作区域和暂存区。 --mixed （默认方式）只改变暂存区，不改变工作区。 --hard 改变工作区和暂存区到指定 commit，所以如果在工作区有修改的情况下进行版本的回退操作，最好先备份，因为工作区会被覆盖。 Stash将工作区内的改动进行暂存，切换到其他分支时，工作区的改动不会被携带过去，使用git stash pop命令就可以将原先的工作区和暂存区改动恢复到工作区，如果要工作区和暂存区的改动各自恢复，需要加--index参数。 ## 将已跟踪的文件压入栈中，未跟踪的文件不会压入栈中 git stash ## 工作区和暂存区的改动都恢复到工作区 git stash pop ## 工作区和暂存区的改动各自恢复 git stash pop --index ## 查看所有的缓存列表 git stash list ## 重新获取某一次缓存，缓存不会消失，需要手动删除 git stash apply stash@{n} ## 删除某一次的缓存 git stash drop stash@{n} Git 命令速查创建分支创建新的分支，可以选择继承的分支 git switch -c [start point] ## 新建一个名为 hello 的分支 git switch -c hello ## 新建一个继承于 dev 的名为 hello 的分支 git switch -c hello dev ## 新建一个名为 hello 的分支并建立与远程分支的映射关系 git switch -c hello origin/dev 切换分支git switch 删除分支删除本地分支 git branch -d 删除远程分支 git push origin -d 合并分支将目标分支合并到当前分支上 git merge 发布分支发布本地分支 git push origin 发布本地分支并与远程分支进行关联 git push -u origin 现在创建一个新的 dev 分支，使用git push orign &lt;branch&gt;来推送和创建远程分支，可以看到通过git branch --vva命令打印出来的分支信息中，dev 分支和 origin/dev 分支是没有进行关联的： 现在换用git push origin -u &lt;branch&gt;进行发布，可以看到 dev 已经与 origin/dev 正确关联。 撤销修改现在假设有个文件叫做 readme.md，因为有暂存区的存在，所以对于修改的撤销可以分为三种情况： 工作区有修改，没有提交到暂存区： ## 这里的双横杠一定要加，不然会被视作分支 git checkout -- readme.md 工作区的修改提交到了暂存区： 这里需要分为两步：首先将暂存区的修改撤销，然后将工作区的修改撤销 ## 从暂存区撤销 git reset readme.md ## 从工作区撤销 git checkout -- readme.md 工作区的修改提交到了暂存区之后，又进行了修改： 这种情况需要在第二部的步骤前再加一步 checkout 操作 ## 从工作区撤销 git checkout -- readme.md ## 从暂存区撤销 git reset readme.md ## 从工作区撤销 git checkout -- readme.md 版本回退保留当前工作区与缓存区的回退： git reset --soft 清空工作区与缓存区的回退： git reset --hard 除了可以使用 commit ID，还可以HEAD~n的形式来快速回退版本： git reset HEAD~ git reset master~2 版本回退后如果需要将当前回退版本更新到远程仓库，则需要下述命令强制更新线上版本： git push --force 版本前进现在有个版本 A、B，将版本回退到 A，此时如果再想回到版本 B，还是通过git reset去实现，但是此时必须获取到 commit ID，然而现在git log已经打印不出 A 版本之后的 commit ID，所以需要使用git reflog命令来打印出每一次命令的 commit ID，然后使用 ID 进行回退。 下图是将版本回退到 A： 下图是将版本前进到 B： 拷贝提交将指定提交应用于其他分支 git cherry-pick 撤销提交对指定提交内的修改进行回退，与 reset 不同的是，它不是直接回退提交，而是会新建一个 commit，在这个新的 commit 内去对指定版本的修改进行反向修改。 git revert 下图展示了 revert 与 reset 的区别 提交标签为了方便查找具体的迭代，可以给某个提交打上标签（tag），之后再分支列表处能看到 tag 列表。 git tag ## 打完标签之后需要手动 push 到远程服务器上： git push origin ## 一次推送多个 tag git push origin --tags 合并提交将多个提交合并成一次提交，保持提交历史的清爽 git merge B --squash 绕过提交校验项目如果配置了 pre-commit-check 且本次提交想绕过提交前的检查，可以使用 --no-verify 来实现 git commit -m \"feat: 绕过校验\" --no-verify 一图总结","link":"/post/c73a59f9/"},{"title":"开发 - 移动端页面适配","text":"移动端适配的基础知识和常见用例 viewport 视口视口可以细分为：视觉视口（visual viewport）和布局视口（layout viewport） 视觉视口视觉视口是页面的可视区域，相当于一个设置了overflow:hidden属性的 div 元素，这是由硬件决定的，不受缩放的影响。 布局视口布局视口的尺寸是内容的初始尺寸，设置 viewport meta 的 width 属性其实就是在设置布局视口的初始尺寸。 如果想在不同尺寸的视觉视口中保持同样的分辨率，那么就需要设置布局视口的宽度。 举个例子，页面中有一张原尺寸 1690px 宽的图片，此时如果设置 viewport 的宽度为 800px： &lt;meta name=&quot;viewport&quot; content=&quot;width=800, initial-scale=1&quot;&gt; 显示效果如下图，html 的宽度既不是 375px 也不是 1690px，而是在 viewport 中设置的 800px，因为图片设置了 100% 的宽度，所以图片的宽度也是 800px，视觉视口并不能完全的显示出布局视口。 如果将 viewport 的宽度设置成小于页面宽度的值，会有什么结果？ &lt;meta name=&quot;viewport&quot; content=&quot;width=300, initial-scale=1&quot;&gt; 效果如下图，宽度设置没有生效，html 使用的是视觉视口的宽度 现在为移动端开发的页面，通常将 viewport 的宽度设置为device-width（设备宽度），即让布局视口宽度与视觉视口宽度相等，这样就不会出现缩放和横向滚动条的问题 缩放属性与缩放有关的值有 4 个： inital-scale：初始缩放比例 maximum-scale：允许用户缩放到的最大比例 minimum-scale：允许用户缩放到的最小比例 user-scalable：用户是否可以手动缩放 meta 属性meta 有些列属性： viewport 视口具体配置见上面的 viewport 视口部分，移动端常用 viewport 配置： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt; charset 字符编码常用的编码为 utf-8 &lt;meta charset=&quot;utf-8&quot; /&gt; cache-control 缓存策略cache-control 的可选值： no-store：不缓存数据到本地 no-cache：在提供给本地读取之前，强制要求缓存把请求提交给原始服务器进行验证（协商缓存） max-age：最大可缓存时间 x-ua-compatible 浏览器版本常用配置：加入客户端安装了 Chrome Frame，则在 IE 中使用 chrome 的渲染引擎来渲染页面，如果没有安装，则使用最高的 IE 版本模式来进行渲染 &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge, chrome=1&quot; /&gt; seo 属性 author 作者 &lt;meta name=&quot;author&quot; content=&quot;something&quot; /&gt; keywords 关键字 &lt;meta name=&quot;keywords&quot; content=&quot;something&quot; /&gt; description 描述 &lt;meta name=&quot;description&quot; content=&quot;something&quot; /&gt; format-detection 格式检测telephone 电话识别safari 浏览器会将疑似电话号码的数字处理为电话链接，比如： 7位数字，形如：1234567 带括号及加号的数字，形如：(+86)123456789 双连接线的数字，形如：00-00-00111 11位数字，形如：13800138000 如果需要关闭电话识别，则需要下述配置： &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot; /&gt; email 邮箱地址识别安卓浏览器会将疑似邮箱地址转换为邮箱链接，如果需要关闭邮箱识别，则需要下述配置： &lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot; /&gt; 高 DPR 适配对于高分屏，例如 Retina 屏幕这样 DRP 大于 1 的屏幕，1位图像素不在对应 1 物理像素，而是使用 4 个及以上的物理像素去模拟 1 位图像素，如下图所示： 不过者也会造成一个问题：将尺寸为 80px 的图片宽度设置为 80px，那么此时 1位图像素对应 1 物理像素，DRP = 2 的高分屏中，位图像素无法在继续分解，那就只能用 4 个物理像素去模拟 1 个位图像素，模拟的方式就是就近取色，这会导致图片有一定的色差，看起来变得模糊 解决方法就是：将图片的尺寸拓展成 80px*DRP，这样每一个位图像素都会有对应的物理像素，图片就会变得清晰。 img 解决方案通过设置 srcset 属性配置显示的图片： &lt;img srcset=&quot;elva-fairy-320w.png, elva-fairy-480w.png 1.5x, elva-fairy-640w.png 2x&quot; src=&quot;elva-fairy-640w.png&quot;/&gt; background 解决方案通过媒体查询页面的 DRP 来决定显示的图片： @mixin bg-image($url,$extension:'.png'){ @media (min-device-pixel-ratio:2){ background-image:url( $url + \"@2x\" + $extension ) } @media (min-device-pixel-ratio:3){ background-image:url( $url + \"@3x\" + $extension ) } } 阻止移动端双击缩放添加下述属性： touch-action: manipulation; 视口高度去除底部栏当使用 height: 100vh 去设置页面高度时，往往会出现如下图所示的将导航栏算入 viewport height 的情况，而我们实际需要的是右侧的结果。 这时候就需要去修改 body 的高度属性，将height:100vh修改为height:fill-available，移动端除了 Opera 其他浏览器基本已经兼容了该属性，具体兼容情况 Safari避免 safari 弹性效果遮挡 fixed 定位的元素解决方式：给 html 标签设置overflow:hidden，给 body 标签设置overflow:auto： html { overflow: hidden; } body { overflow: auto; } border-radius 在 safari 上的失效问题如果元素设置了 border-radius 属性且设置了 transform 属性，那么 border-radius 就会失效，解决方法是：给父元素加上 transform:translateX(0) 属性。 :active 状态失效safari 中为按钮元素添加 :active 默认是不会生效的，只有在按钮元素绑定 touchstart 事件时才能激活 :active 状态，只需要给 touchstart 绑定一个空事件即可。 根据设备宽度计算全局字体在引入全局css样式之前调用下述代码，通过设置 defaultFontSize 来定义 375 宽度下字体的大小，其他宽度的设备会以 defaultFontSize 和 375 宽度作为标准，动态改变全局字体大小。 (function (doc, win) { var defaultFontSize = 20; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () { var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = defaultFontSize * (clientWidth / 375) + 'px'; }; recalc(); if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); })(document, window); 判断当前浏览器/机型navigator.userAgent 能获取到当前浏览器的 user agent 字符串 判断是否为微信浏览器const ua = navigator.userAgent.toLowerCase(); const isWeixin = /micromessenger/i.test(ua); 判断是否为安卓const ua = navigator.userAgent.toLowerCase(); const isAndroid = /android/i.test(ua); 判断是否为iOSconst ua = navigator.userAgent.toLowerCase(); const isIOS = /(iPhone|iPod|iPad);?/i.test(ua);","link":"/post/98cf4503/"},{"title":"算法基础 - 快速排序","text":"三路快排：快速排序的一个优化版本 其主要过程： 首先随机取一个数，将其作为锚点； 定义三个数组，用于存储大于、等于、小于锚点的数； 对数组进行循环，将数组的数分配到各个数组内； 对大于和小于锚点的数组进行递归操作； 最后返回一个解构后的新数组； 这里有非常直观的可视化排序过程：visualgo 实现function quickSort(arr) { // 如果数组为空，则直接返回 if(arr.length&lt;=0) return []; // 取数组中间数作为锚点 const pivot = arr[Math.floor(arr.length/2)] ; // 定义三个数组，left 用于存储小于锚点的数，mid 存储等于锚点的数，right 存储大于锚点的数 const left = [], mid = [], right = []; // 对数组进行循环，将数放到指定的数组中 for( let i = 0; i&lt;arr.length; i++ ){ if( arr[i] &lt; pivot ){ left.push(arr[i]) }else if(arr[i] === pivot){ mid.push(arr[i]) }else{ right.push(arr[i]) } } // 左右数组再次调用快排，并对三个数组进行解构，返回一个新数组 return [...quickSort(left), ...mid, ...quickSort(right)] } 测试用例const testArray = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48,]; console.log(quickSort(testArray));","link":"/post/e9fb4af7/"},{"title":"拓展 - typescript笔记","text":"学习 TypeScript 笔记，仅记录一些容易混淆的知识点 数据类型void 空值可以表示没有任何返回值的函数 function alertName(): void { alert('My name is Tom'); } 也可以用于表示只能被设置成 null 或 undefined 的变量 let unusable: void = undefined; Null/Undefinednull 和 undefined 是所有类型的子类，也就是说 null / undefined 类型的变量能够赋值给 number 类型的变量 let num: number = undefined; // or let u: undefined; let num: number = u; 类型推论当没有明确指定类型时，会在编译时进行推断，例如给一个变量赋值字符串，那么 ts 就会推断为 string 类型 let myFavoriteNumber = 'seven'; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 联合类型联合类型表示取值可以为多种类型中的一种 let myFavoriteNumber: string | number; myFavoriteNumber = 'seven'; myFavoriteNumber = 7; 当 ts 无法确定一个联合类型的变量是哪个类型的时候，就会使用类型推断来确定其类型，在没有进行推断之前，只能访问联合类型的所有类型里的共有属性和方法，下例中因为 number 没有 length 方法，所以 ts 报错 function getLength(something: string | number): number { return something.length; } // index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'. // Property 'length' does not exist on type 'number'. 接口在 TS 中使用 interface（接口）去定义对象的类型。 可以通过readonly去定义只读属性，TS 会在修改只读属性时报错。 interface Person { readonly id: number; name: string; } 接口之间可以互相继承： interface Alarm { alert(): void; } interface LightableAlarm extends Alarm { lightOn(): void; lightOff(): void; } 有点特别的是，接口可以继承类： class Point { x: number; y: number; constructor(x: number, y: number) { this.x = x; this.y = y; } } interface PointInstanceType { x: number; y: number; } // 等价于 interface Point3d extends PointInstanceType interface Point3d extends Point { z: number; } let point3d: Point3d = {x: 1, y: 2, z: 3}; 函数类型函数的类型定义要区分 函数声明 和 函数表达式。 函数声明，定义好入参和返回的类型即可： function sum(x: number, y: number): number { return x + y; } 函数表达式的类型定义要比函数声明来的复杂，定义同一个函数： let sum: (x: number, y: number) => number = function (x: number, y: number): number { return x + y; }; 当然也可以使用接口去定义： interface Sum { (x: number, y: number): number; } let sum: Sum; sum = function(x: number, y: number) { return x + y; } 类型别名这是之前我一直和 interface 混淆的概念，类型别名用来给一个类型起新的名字，常用于联合类型： type Name = string; type NameResolver = () => string; type NameOrResolver = Name | NameResolver; function getName(n: NameOrResolver): Name { if (typeof n === 'string') { return n; } else { return n(); } } 这里用到了 type 关键字去定义类型别名，在 TS 中，定义字符串字面量类型用的也是 type 关键字： type EventNames = 'click' | 'scroll' | 'mousemove'; function handleEvent(ele: Element, event: EventNames) { // do something } 断言断言，即手动指定一个值的类型。 断言的使用有一定的限制，如果想让 A 与 B 能兼容，那么 A 能被断言成 B，B 也能被断言成 A。 举个例子，下面的 Animal 和 Cat 的关系可以看做是 Cat extends Animal，Cat 能和 Animal 兼容，所以他们能互相断言。 interface Animal { name: string; } interface Cat { name: string; run(): void; } function testAnimal(animal: Animal) { return (animal as Cat); } function testCat(cat: Cat) { return (cat as Animal); } 下面列举了3种常见的使用场景： 常遇见的一个状况就是在联合类型中，只能使用所有类型共有的属性和方法，如果需要使用某个类型的特有方法，就需要使用断言来指定类型： interface Cat { name: string; run(): void; } interface Fish { name: string; swim(): void; } function getName(animal: Cat | Fish) { return animal.swim(); // 这里会报错 } // 但使用断言后便不会报错 function isFish(animal: Cat | Fish) { return (animal as Fish).swim(); } 还可用于将一个父类断言为更具体的子类： interface Animal { name: string; } interface Cat { name: string; run(): void; } const animal: Animal = { name: 'tom' }; let tom = animal as Cat; 当使用类型声明去定义 tom 变量时，是会报错的，因为不能将父类的实例赋值给类型为子类的变量： interface Animal { name: string; } interface Cat { name: string; run(): void; } const animal: Animal = { name: 'tom' }; let tom: Cat = animal; // 此处会报错 还有一种情况就是，TS 会在不存在属性或方法时进行报错，但是有时候我们确定某个方法或者属性不会出错，就可以使用断言去忽略： (window as any).foo = 1; 枚举枚举解决了状态判断的痛点，下面是对于状态值判断的一段代码，从代码中很难看出值1对应的状态： function handleStatusChange(status) { if(status == 1){ // do somthing }else if(status == 2){ // do somthing }else if(status == 3){ // do somthing } } 如果使用枚举，且如果是数字枚举，那么 enum orderStatus { UN_PAYED, // 未支付 PAYED, // 已支付 CANCELED, // 已取消 } 那么上述的代码就可以修改为： function handleStatusChange(status) { if(status == orderStatus['UN_PAYED']){ // do somthing }else if(status == orderStatus['PAYED']){ // do somthing }else if(status == orderStatus['CANCELED']){ // do somthing } } 枚举又可以分为数字枚举和字符串枚举。 他们的区别就在于：数字枚举既可以用枚举名称来索引，也可以用枚举值来索引；而字符串枚举只能够通过枚举名称来索引，不能通过枚举值来反向索引。 enum orderStatus { UN_PAYED, PAYED, CANCELED, } orderStatus.UN_PAYED // 0; UN_PAYED[0] // \"UN_PAYED\"; 从他们被编译的结构上，就可以看出区别： // 数字枚举 enum orderStatus { UN_PAYED, PAYED, CANCELED, } var orderStatus; (function (orderStatus) { orderStatus[orderStatus[\"UN_PAYED\"] = 0] = \"UN_PAYED\"; orderStatus[orderStatus[\"PAYED\"] = 1] = \"PAYED\"; orderStatus[orderStatus[\"CANCELED\"] = 2] = \"CANCELED\"; })(orderStatus || (orderStatus = {})); // 字符串枚举 enum orderStatus { UN_PAYED = \"A\", PAYED = \"B\", CANCELED = \"C\", } var orderStatus; (function (orderStatus) { orderStatus[\"UN_PAYED\"] = \"A\"; orderStatus[\"PAYED\"] = \"B\"; orderStatus[\"CANCELED\"] = \"C\"; })(orderStatus || (orderStatus = {})); 如果在枚举之前加上const，就是常量枚举，不同于常规的枚举，他们在编译阶段会被删除，减少额外开销： const enum orderStatus { UN_PAYED, PAYED, CANCELED, } 类修饰符TS 提供了三种修饰符：public、private 和 protected public：修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的； private： 修饰的属性或方法是私有的，不能在声明它的类的外部访问； 在子类中也不能访问； 当构造函数用 private 进行修饰时，该类不能被继承或者实例化； protected：在子类中允许被访问的 private 属性或方法，当构造函数用 protected 进行修饰时，该类只允许被继承； 参数属性修饰符和 readonly 还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁： class Animal { public name: string; public constructor(name) { this.name = name; } } // 可以简写为 class Animal { public constructor(public name) { } } 如果需要加上 readonly 只读属性关键字： class Animal { // public readonly name; public constructor(public readonly name) { // this.name = name; } } 类与接口interface（接口）通过 implements 进行实现（定义）： // 共有特性 interface Alarm { alert(): void; } class Door { } class SecurityDoor extends Door implements Alarm { alert() { console.log('SecurityDoor alert'); } } class Car implements Alarm { alert() { console.log('Car alert'); } } 一个类可以实现多个接口： interface Alarm { alert(): void; } interface Light { lightOn(): void; lightOff(): void; } class Car implements Alarm, Light { alert() { console.log('Car alert'); } lightOn() { console.log('Car light on'); } lightOff() { console.log('Car light off'); } } 一些特殊的场景键名如果要去定义一个对象的键和值的类型，就需要如下操作： interface DataInterface = { query?: { [key: string]: number | string }; } Promise如果要定义 Promise 的 resolve 和 reject 的值的类型，可以在创建 Promise 时在后面跟上泛型，例如： function foo(){ return new Promise&lt;number>((resolve,reject)=>{ resolve(123) }); } 定义Ref在 react 中定义 ref 时，可以使用 RefObject&lt;&gt; 的形式定义，例如定义一个 inputRef： const inputRef: RefObject&lt;HTMLInputElement> = useRef(null);","link":"/post/7d8129ab/"},{"title":"浏览器 - TCP 协议与 HTTP 请求","text":"TCP 协议和 HTTP 请求的基础知识，HTTPS 的工作模式 TCP 的三次握手TCP 建立连接的时候需要“三次握手”： 第一次握手：建立连接时， 客户端发送 syn 包到服务器，等待服务器确认； 第二次握手：服务器收到 syn 包，确认客户端的 SYN，同时自己也发送一个 SYN+ACK 包给客户端； 第三次握手：客户端接收到 SYN+ACK 包，向服务端发送 ACK 包，此包发送完毕，TCP 链接成功； 三次握手的目的是：为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。如果采用二次握手，因为 A 端到 B 端的请求可能在某个网络节点上发生滞留，过了一段时间后才到达 B 端，对于 A 来说这已经是一个失效的报文，但 B 会误认为这是一个新的报文而与 A 建立连接。A 不会再通过这个连接发送数据，B 没有收到数据会一直等待，导致资源的浪费。 TCP 的四次挥手TCP 在关闭连接的时候需要四次挥手： 客户端发送一个 FIN 给服务端用于关闭 TCP 连接； 服务端接收 FIN 之后发送一个 ACK 给客户端； 服务端先关闭客户端的连接，然后发送一个 FIN 给服务端； 客户端发回 ACK 确认； 为什么 B 还需要告诉 A 要关闭连接呢？因为 A 想关闭连接时 B 可能还没有传输完数据，所以连接还不能被真正地关闭（此时处于半关闭状态）。 HTTP 协议HTTP 协议是一种基于TCP/IP通信协议来传输数据的一种无状态协议，无状态协议不要求服务器在多个请求期间保留有关每个用户的信息或状态。 HTTP/1.1HTTP/1.1 标准解决了早期版本中发现的许多协议歧义，并引入了许多关键性能优化：keep-alive 连接，分块编码传输，字节范围请求，附加缓存机制，传输编码和管道式请求。 keep-alive 连接： 允许复用现有的 TCP 连接，以便于处理同一主机发出多个请求（除非特别声明头部Connection: close，否则默认使用 keep-alive）。 开启了 keep-alive 时，请求结束，TCP 连接不断开，继续保持一段时间，在这段时间内，同一客户端向服务器发送请求都会复用该 TCP 连接并重置 timeout 时间计数器，在接下来 timeout 时间段内还可以继续复用 TCP 连接。 但是他也有一个缺点：每次请求必须等待上一次响应之后才能发起； 分块编码传输：允许将服务端到客户端的数据分成多个部分进行传输； 字节范围请求：请求头的 Range 属性，可以获取指定范围字节的数据； 附加缓存机制：强缓存和协商缓存； 传输编码：传输编码是为了分块传输而设计的，能够改变报文的格式和传输的方式； 管道式请求：相对于 keep-alive 连接的又一性能优化，可以将多条请求放入队列，无需等待服务器对前一个请求进行相应。但默认不开启，因为这要求服务端必须按照请求发送的顺序进行响应，当顺序请求多个文件时，其中某一个请求因为某种原因被阻塞时，后面排队的所有请求也一并被阻塞，这就是队头阻塞。 HTTP/2.0HTTP/2 的主要关注点是提高传输性能并实现更低的延迟和更高的吞吐量。 那么 HTTP/2.0 多路复用和 HTTP/1.1 keep-alive 有什么区别？ HTTP/1.1 是基于文本的，只能整体去传递；而 HTTP/2 是基于二进制流的，可以分解为独立的帧，交错发送； HTTP/1.1 keep-alive 单个 TCP 连接在同一时刻只能处理一个请求，而 HTTP/2.0 单个 TCP 连接能够在同一时刻处理多个请求和响应； HTTP/1.1 keep-alive 必须按照请求发送的顺序返回响应，而 HTTP/2.0 不需要； HTTP/1.1 keep-alive 为了解决队头阻塞，需要将同一个页面的资源分散在不同域名下，开启多个 TCP 连接，而 HTTP/2.0 所有通信都可以在单个连接上完成； HTTP 请求当我们在浏览器里输入一个域名并访问的时候，浏览器会将该域名发送给 DNS 服务器，服务器将其解析为 IP 地址，浏览器与 IP 地址所对应的服务器建立 TCP 连接，然后才发送 HTTP 请求。 HTTP 请求可以分为 3 个部分：请求行、请求头、请求体 请求行请求行包含了方法、URL 和 HTTP 版本信息，方法是指请求的类型： GET：从服务器取回数据 POST：上传文件或者表单 PUT：更新已有实体 DELETE：删除资源 TRACE：返回请求发生时，服务端收到的内容 HEAD：仅返回头部，不返回响应体 OPTIONS：返回服务端支持的请求方法 CONNECT：用来建立一个对资源的网络连接 请求头请求头内包含着 Accept-Charset（客户端可接受的字符集）、Content-Type（正文格式）、Cache-Control 等字段。 HTTPS 请求HTTPS 请求是结合了对称加密和非对称加密的 HTTP 请求 对称加密对称加密：客户端和服务端存有相同的秘钥，使用秘钥产生的密文可以在任意端解密。这是效率很高的加密方式，但是在服务端发送秘钥给客户端的过程中，秘钥很容易被截获。 非对称加密非对称加密：服务端保存私钥，客户端保存公钥，私钥生成的密文可以使用公钥解密，公钥生成的密文可以使用私钥解密。服务端将公钥发送给客户端，客户端生成的密文没有服务端的私钥是解不开的，解决了对称加密的安全性问题。不过只使用一对公私钥加密是不够的，因为公钥是公开的，所以任何人都可以模拟发送请求，任何人都可以解密服务端发出的信息，所以客户端也需要配置自己的公私钥，并且将客户端的公钥发送给服务端，这样即使请求被拦截，请求里面的密文也不会被他人解密。 中间人攻击HTTPS 使用了非对称加密+对称加密的形式，但在非对称加密阶段可能遭到中间人攻击。 如果中间人劫持了服务器发送给客户端的公钥明文 M，并将中间人的虚假公钥 X 传递给客户端，对于客户端来说并不知道公钥 M 已经被替换了，会使用虚假公钥 X 生成对称加密的密钥 D。 此时中间人就可以通过自己的私钥 XX 去解密请求里用虚假公钥 X 加密的信息，然后再用公钥 M 对信息进行包装，发送给服务端，整个过程无法被发现。 出现中间人攻击的原因就是浏览器无法判断公钥是否来自正确的服务端，此时就需要用到数字证书，用来证明当前公钥的身份。 数字证书数字证书的生成，简单的来说，就是：将明文的哈希值用私钥加密，然后将明文和加密后的哈希值打包发送给客户端，在客户端用公钥解密，并重新计算明文的哈希值，如果两个哈希值一致，说明没有被篡改。 详细步骤： 如果将所有者的公钥、证书所有者、发布机构和有效期等信息称作明文M， CA 会先对明文 M 进行 hash 运算产生文件 H，然后使用 CA 的私钥对文件 H 进行加密，得到签名 Q，然后将明文 M 和签名 Q 合并成一个文件，就获得了数字证书。 客户端在获得数字证书之后，会通过 CA 的公钥对签名 Q 进行解密，得到 hash 值，然后对明文 M 进行 hash 运算，如果解密获得的 hash 值和运算生成的 hash 值一致的话，那么说明这个证书是未被篡改的。 Tips： 浏览器和操作系统内一般内置了权威的 CA 机构的数字证书，用于获取到正确的 CA 公钥。 如果在根证书中加入数字证书K，就能让浏览器信任该证书，就可以实施中间人攻击了，charles就是使用这种模式来抓包 Https 的。 HTTPS 的工作模式下图反应的是 HTTPS 的工作模式， 客户端首先生成一个随机数，然后将【加密算法列表、客户端生成的随机数】发送给服务端。 服务端将客户端发送过来的随机数存储下来，然后自己生成一个随机数，并在加密算法列表中选择一个算法，将【选择的算法、服务端生成的随机数、服务端证书】发送给客户端，最后告诉客户端：信息发送完成。 客户端对服务端发送过来的证书进行校验，获得服务端的公钥，然后生成一个【对称加密用的随机数字】，使用公钥进行加密，发送给服务端。 服务端接收到客户端发送过来的密文，使用本地私钥进行解密，算出【对称加密用的随机数字】。 现在双方都存在：客户端的随机数、服务端的随机数、对称加密用的随机数，使用这几个参数生成对称加密的秘钥，那么现在就可以尝试使用对称加密进行传输了。 HTTPS是否需要每次请求都生成新的密钥？服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了。 附录常用状态码200 ：ok，请求成功 201：created，成功请求并创建了新的资源 202：accepted，已接受请求但未处理完成 301：永久重定向 302：临时重定向 304：not modified，所请求的资源未修改，用于协商缓存 400：bad request，客户端请求语法错误 401：unauthorized，请求要求用户身份认证 403：forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求 404：not found，无法找到请求的资源 500：internal server error，服务器内部错误 501：not implemented，服务器不支持请求的功能，无法完成请求 502：bad gateway，从远程服务器接收到了一个无效的响应 503：service unavailable，由于超载或者系统维护，服务器暂时无法处理客户端的请求","link":"/post/997c7fc1/"},{"title":"CSS 基础","text":"CSS 基础知识及常用拓展 CSS选择器 标识案例 名称 说明 * 通用选择器 选择所有元素 p 元素选择器 按照给定的节点名称，选择所有匹配的元素 .hello 类选择器 按照给定的类名，选择所有匹配的元素 #world ID选择器 按照给定的ID，选择唯一匹配的元素 [attr=value] 属性选择器 按照给定的属性，选择所有匹配的元素，匹配规则在下面 div,span 选择器列表 使用,将不同组合器组合在一起，选择能被列表中的任意一个选择器选中的节点 div span 后代选择器 使用空格选择前一个元素的后代节点 div&gt;span 直接后代选择器 使用&gt;选择前一个元素的直接子代的节点 div~span 一般兄弟选择器 使用~选择兄弟元素，后一个节点在前一个节点后面的任意位置，且共享同一个父节点，例如 div~span 匹配同一个父元素下，&lt;div&gt;元素后的所有&lt;span&gt;元素 div+span 相邻兄弟选择器 使用+选择该节点之后的兄弟元素，后一个节点紧跟前一个节点，并且共享同一个父节点 属性选择器提供了多种语法来实现复杂匹配： [attr]：标识带有以 attr 命名的属性的元素； [attr=value]：标识带有以 attr 命名的属性，且属性值为 value 值的元素； [attr~=value]：标识带有以 attr 命名的属性，且该属性是一个以空格作为分割的值列表，其中至少有一个属性值为 value 值的元素； 举个例子： &lt;div lang=\"en-us en-gb en-au en-nz\">Hello World!&lt;/div> 这里就可以通过 div[lang~=&quot;en-gb&quot;]来匹配到上面的元素 [attr|=value]：标识带有以 attr 命名的属性，且属性值为 value 或者 value- 为前缀的元素； 举个例子： &lt;div lang=\"en-us en-gb en-au en-nz\">Hello World!&lt;/div> 这里可以通过 div[lang|=&quot;en&quot;]来匹配上面的元素，该匹配规则常用于匹配语言简写。 [attr^=value]：标识带有以 attr 命名的属性，且属性值是以 value 值开头的元素； [attr$=value]：标识带有以 attr 命名的属性，且属性值是以 value 值结尾的元素； [attr*=value]：标识带有以 attr 命名的属性，且属性值至少包含一个 value 值的元素； &lt;div lang=\"nononoen\">Hello World!&lt;/div> 使用[lang*=&quot;en&quot;]能够匹配到上面的元素 [attr operator value i]：operator 为上述的匹配表达式，在 value 后添加 i 标识符就能够忽略值的大小写； 举个例子： &lt;div lang=\"ABC\">Hello World!&lt;/div> 使用[lang=&quot;abc&quot; i]能够匹配到上面的元素 CSS 优先级浏览器根据 CSS 的优先级来决定给元素应用哪个样式 选择器的优先级从高到低：!important &gt;内联样式 &gt; ID选择器 &gt;【类选择器、属性选择器、伪类、伪元素】&gt; 元素选择器 &gt; 通用选择器 对于多选择器的情况，就需要计算其权重来决定应用哪个样式 样式的权重 = 内联样式 * 1000 + ID选择器的数量 * 100 + 类选择器的数量 * 10 + 元素选择器的数量 * 1 a{ color: red } /* 权重 10 */ #box a{ color: green } /* 权重 110 */ 需要注意的是： 优先级无法通过权重升位，例如：1个ID选择器与20个类选择器组成的集合作比较，此时类选择器的权重是 200 高于ID选择器，但是样式仍然由 ID 选择器决定，低优先级的选择器始终无法覆盖高优先级的选择器。 如果当计算出的权重相等时，后面的样式会覆盖前面的样式。 !important 拥有最高优先级，如果要覆盖其样式，可以使用更高优先级的选择器。 百分比参照物在CSS中使用百分比首先需要知道百分比相对于谁，这里罗列了一些常见的CSS样式： 相对于父级的宽的属性： width、min-width、max-width、left、right、text-indent、margin、padding 需要注意的是：这里的宽是指 content-area，并不包含 padding / margin / border，即使父元素设置了 box-sizing : border-box。 相对于父级的高的属性： height、min-height、max-height、top、bottom 相对于自身宽高的属性： border-radius、background-size、transform、transform-origin、zoom 、clip-path 相对于自身字号： line-height Flex 计算方式flex-grow 计算方式假设有三个元素 width 属性值分别为：100、150、100，各自的 flex-grow 值为 1、2、3，父元素的宽度为 500，此时三个元素的实际宽度时多少？ flex-grow 是在原有的宽度基础之上分配多余的空间，父元素多余的空间是 500-(100+150+100) = 150，然后 150 被等分成 6 份，添加到各自的元素上，所以最后三个元素的增加的宽度分别为： (1/6) x 150 = 25;(2/6) x 150 = 50;(3/6) x 150 = 75; 但如果三个 flex-grow 的值之和小于 1 呢？例如 flex-grow 的值分别为 0.1、0.2、0.3，那么多余的空间不会被全部分配到三个元素上，三个元素的宽度分别为： 150 x 0.1 = 15；150 x 0.2 = 30；150 x 0.3 = 45； flex-shrink 计算方式flex-shrink 默认值为 1，每个元素的收缩权重是其 flex-shrink 的值乘以其宽度。 假设有三个元素 width 属性值分别为：150、200、300，各自的 flex-shrink 值为 1、2、3，父元素的宽度为 500，需要被收缩的宽度为 150，按照上面的计算方式，得出三个元素的总权重为： 150 x 1 + 200 x 2 + 300 x 3 = 1450 每个元素被收缩的宽度为： 150 x (150 x 1 / 1450) = 15.5150 x (200 x 2 / 1450) = 41.4150 x (300 x 3 / 1450) = 93.1 如果三个 flex-shrink 的值之和小于 1，例如各自的 flex-shrink 值为 0.1、0.2、0.3，第一步还是计算总权重，得出 145，因为 flex-shrink 的值之和小于 1，所以多出的 150 宽度并不会被全部收缩，只会收缩一部分：150 * (0.1+0.2+0.3) = 90，那么三个元素被收缩宽度分别为： 90 x (150 x 0.1 / 145) = 9.390 x (200 x 0.2 / 145) = 24.890 x (300 x 0.3 / 145) = 55.8 怪异盒模型怪异盒模型：IE5/6将内边距和边框计入宽度和高度，我们称之为怪异盒模型； 标准盒模型：width 和 height 指的是内容区域（content-area）的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，这是W3C指定的标准模型。 通过设置 box-sizing 属性，可以将标准盒模型转换为怪异盒模型。 灰度转换filter: grayscale(amount) : 对元素进行灰度转换，amount 介于 0 到 1 之间，默认为 0，可用作禁止访问效果。MDN 水平/垂直翻转scaleX(-1)或者scaleY(-1)可以实现基于水平/垂直翻转 .flipx{ transform:scaleX(-1); // 水平翻转 } .flipx{ transform:scaleY(-1); // 垂直翻转 } inline、block、inlineBlockinline（行内元素）： 行内元素不会独占一行，多个相邻行内元素会排列在同一行里，直到一行内排列不下才会换行，其宽度随内容的变化而变化； 行内元素无视 width 和 height 属性； 行内元素无视竖直方向的 margin 和 padding 属性，但是水平方向的 margin 或 padding 会生效； block（块级元素）： 块级元素会独占一行，其宽度默认填满父级元素； 块级元素可设置 width 和 height 属性； 块级元素水平和竖直方向的 margin 和 padding 属性都会生效； inline-block（行内块级元素）： 除了不会独占一行，其他特性和块级元素保持一致； 自适应图片的实现根据DPR选择如果统一使用普通分辨率的图片，在 Retina 屏幕下会显得很模糊；如果统一使用高分辨率的图片，则会增加带宽的压力。所以不同分辨率的屏幕应该使用不同分辨率的图片以达到最好的显示效果，要实现这个效果就需要使用 srcset 属性： &lt;img src=\"photo.png\" srcset=\"photo@2x.png 2x\" /> 根据尺寸选择根据DPR选择图片的写法简单，但是容易出错，例如：iphone 和 macbook 的 DPR 都是 2，但是 iphone 只需要 828px 宽度的图片就可以全屏展示，但是 macbook 需要 2880px 宽度的图片才能够实现全屏展示。这时候就需要根据实际需要尺寸选择图片，将 dpr 换做实际宽度： &lt;img src=\"https://via.placeholder.com/600\" srcset=\"https://via.placeholder.com/600 600w, https://via.placeholder.com/1200 1200w, https://via.placeholder.com/1800 1800w, https://via.placeholder.com/2400 2400w\" /> 浏览器会根据屏幕的逻辑像素宽度（screen.width）乘以 DPR 得出的结果，选取最佳尺寸的图片，例如屏幕宽度为 1080px，DPR为2，那么计算的结果为 2160，与 2400 最为接近，所以会选取图片 photo2400w。 不过这种写法只适合全屏图片显示的场景，因为设备宽度是恒定不变的，所以图片不会随着可视宽度的变化而变化。如果要根据视口宽度而不是设备宽度来显示对应图片，那就需要再给 img 标签加上 sizes 属性，sizes 最小单位是由媒体查询语句和对应的图片大小构成的字符串，多个单位用逗号进行分隔 &lt;img src=\"https://via.placeholder.com/600\" srcset=\"https://via.placeholder.com/600 600w, https://via.placeholder.com/1200 1200w, https://via.placeholder.com/1800 1800w, https://via.placeholder.com/2400 2400w\" sizes=\"(max-width: 600px) 300px, (max-width: 1200px) 600px, (max-width: 1800px) 900px, (max-width: 2400px) 1200px, 600px\"/> 上述的 sizes 属性表示的是：当视口宽度小于 1200px 且大于 600px 时，图片的宽度会被设置成 600px，如果设备的 DPR 为 2，那么计算结果就是 600 * 2 = 1200，就会选择 1200w 对应的图片。 在实际开发中时，发现如果视口从小到大变化，图片会自适应加载更大的图片，但是从大到小变化时并不会加载更小的图片，这是因为浏览器在拥有更高的分辨率的图片时，就会忽略质量更低的图片 picture 标签上面方法解决了尺寸和 DPR 自适应的问题，但是可读性太差，有没有可读性更好的写法？ 有！&lt;picture/&gt; 标签能将尺寸配置和 DPR 配置分割开来，具有更好的可读性，需要注意的是 picture 标签内只能存在一个&lt;img/&gt;标签。 &lt;picture> &lt;source media=\"(min-width: 800px)\" srcset=\"head.jpg, head-2x.jpg 2x\"> &lt;source media=\"(min-width: 450px)\" srcset=\"head-small.jpg, head-small-2x.jpg 2x\"> &lt;img src=\"head-fb.jpg\" srcset=\"head-fb-2x.jpg 2x\" alt=\"a head carved out of wood\"> &lt;/picture> 背景图片的DPR自适应上面提到的图片自适应都是基于&lt;img/&gt;标签的，但很多场景中需要用到背景图片，这时候就可以使用image-set()函数来加载不同版本的图片，需要注意的是，image-set()函数目前只有 Chrome 和 Safari 浏览器进行了兼容。 background-image: image-set( url(icon1x.jpg) 1x, url(icon2x.jpg) 2x /*在DPR为2时，会加载图片 icon2x.jpg*/ ); 媒体查询通过媒体查询中的min-resolution也可以实现高分辨率图片的加载，需要注意的是，min-resolution目前只有 Chrome 、Safari 和 Firefox 浏览器进行了兼容。 @media (min-resolution: 2dppx), (-webkit-min-device-pixel-ratio: 2) { /* 高分辨率的图片资源 */ } CSS ModulesCSS Modules 是使用构建工具（例如 webpack），实现样式局部作用域的效果，用于避免样式间的污染，举个例子： 将 CSS 文件引入 import type from \"./type.css\"; element.innerHTML = `&lt;h1 class=\"${type.display}\"> This is a heading &lt;/h1>`; 在 webpack 的配置中打开 css-loader 的 modules 选项 module: { rules: [ { test: /\\.css$/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true } } ] } ] } 构建工具会将以下 CSS 代码和类名进行转换 /** type.css **/ .serif-font { font-family: Georgia, serif; } .display { font-size: 30px; line-height: 35px; } 转换后的结果如下，所有的类名都变成了哈希值 ._3Ukt9LHwDhphmidalfey-S { font-family: Georgia, serif; } ._3XpLkKvmw0hNfJyl8yU3i4 { font-size: 30px; line-height: 35px; } &lt;h1 class=\"_3XpLkKvmw0hNfJyl8yU3i4\"> This is a heading &lt;/h1> 如果我们需要让类名更可读一些，可以配置 css-loader 的 localIdentName 属性 { loader: &quot;css-loader&quot;, options: { modules: true, localIdentName: '[path][name]__[local]--[hash:base64:5]' } } 此时生成的就是类似 src-style-index__display-sxU8x的类名。 如果想让某些样式变成全局样式，不进行类名的转换，可以使用:global() :global(.serif-font) { font-family: Georgia, serif; }","link":"/post/58d5387c/"},{"title":"CSS 块格式化上下文（BFC）","text":"BFC 的基础概念和常见用途 定义块格式化上下文（Block Formatting Context）是一个独立的渲染区域，其最有用的一个特性便是：各个 BFC 之间不会互相影响。 常见的 BFC 元素： 根元素（&lt;html&gt;） 浮动元素（float）、行内块元素（inline-block） 弹性元素（flex）、网格元素（grid） 相对/绝对定位元素（absolute/fixed） overflow 属性不为 visible 的元素（常用） 用途BFC 常见的用途有三种： 清除浮动 清除边距折叠 实现自适应布局 清除浮动首先来了解一下浮动，float 的原始作用是为了实现文字环绕效果，可以理解为部分脱离文档流。 脱离文档流分为两种： 部分脱离文档流：例如 float ，使用 float 属性后，其他 block 盒子会无视 float 元素进行布局，但是其他盒子内的 inline 元素和 inline-block 元素依旧会为这个浮动的盒子让出位置。 完全脱离文档流：例如position:absolute，使用绝对定位的盒子，其他盒子无论是其本身还是里面的任何元素都会无视这个绝对定位的盒子进行布局。 当一个元素被设置成浮动时，就会部分脱离文档流，无法撑开其父元素，导致各类显示问题，所以需要进行清除浮动，下面是一个常见的例子，浮动元素没有将父元素的高度撑开造成了高度塌陷。 clear 清除浮动设置了clear:left/right的盒子，不允许和左/右侧的浮动元素相邻，设置了clear:both的盒子，左右两侧的都不能与浮动元素相邻。 这是未设置clear: both的效果： 这是设置了clear: both的效果： 现在已经知道为浮动元素的兄弟元素添加 clear 属性能够达到清除浮动的效果，这个元素可以使空白的 div ，也可以是伪元素。对于用于清除浮动来说，clear 的值是left、right 还是 both 取决于浮动元素在左侧还是右侧，因为只需要这个属性让元素与浮动元素不相邻即可。 下面为使用伪元素清除浮动： BFC 清除浮动BFC 清除浮动和 clear 清除浮动的区别在于：BFC 是为父元素添加属性，比如添加 overflow:hidden，父元素变成了 BFC，可以包裹浮动流，即使内部所有元素都是浮动元素，都不会产生高度塌陷。 清除边距折叠在同一个 BFC 内，两个或多个毗邻的普通流中的元素（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，取较大值显示，这种形成的外边距称之为外边距叠加。例如：父元素设置了 margin-top=5px，子元素设置了 margin-top=10px，会导致父元素实际显示的是 margin-top=10px 的效果 这里要注意的是元素之间必须是毗邻的，不能存在 padding 或 border，而且只有在垂直方向会发生折叠，水平方向并不存在折叠的情况。 要解决重叠的问题，只需要让他们不存在与同一个 BFC 内即可，对于相邻元素，只要给他们各自都加上 BFC 外壳，就能消除重叠，对于嵌套元素，只需要让父元素触发 BFC 就能消除折叠。 实现自适应布局由于各个 BFC 之间互不影响，所以当一个浮动元素和 BFC 相邻时，并不会出现覆盖的现象，利用这个特点，可以实现两列或多列的自适应布局。 举个例子，right block 触发了 BFC，它便不会受到 left block 是浮动元素的影响，左列大小变化时，右列也会跟着变化，可以实现自适应布局效果。","link":"/post/e15a24d1/"},{"title":"拓展 - webpack的配置与优化","text":"包含 webpack 的运行机制、基础配置以及打包优化方面的知识 运行机制webpack 的运行过程可以简单概述为如下流程： 初始化配置参数 -&gt; 绑定事件钩子回调 -&gt; 确定Entry逐一遍历 -&gt; 使用loader编译文件 -&gt; 输出文件 整个过程就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。 webpack 的详细运行过程如下： webpack 会读取你在命令行传入的配置以及项目里的 webpack.config.js 文件，初始化本次构建的配置参数，并且执行配置文件中的插件实例化语句，生成 Compiler 传入 plugin 的 apply 方法，为 webpack 事件流挂上自定义钩子。 webpack开始读取配置的 Entries，递归遍历所有的入口文件。 webpack 会依次进入其中每一个入口文件(entry)，先使用用户配置好的 loader 对文件内容进行编译（buildModule），之后再将编译好的文件内容解析生成 AST 静态语法树，分析文件的依赖关系逐个拉取依赖模块并重复上述过程，最后将所有模块中的 require 语法替换成 webpack_require 来模拟模块化操作。 所有文件的编译及转化都已经完成，包含了最终输出的资源，我们可以拿到输出的资源、代码块chunk 等等信息。 这里涉及到插件（plugin）和 解析器（loader） loader：它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。 plugin：它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务，比如打包优化、文件管理、环境注入等。 插件从形态上看，插件通常是一个带有 apply 函数的类： class SomePlugin { apply(compiler) { } } webpack 会在启动后按照注册的顺序逐次调用插件对象的 apply 函数，同时传入编译器对象 compiler ，例如： plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ template: resolve(__dirname, 'index.html'), cache: true }), new CopyPlugin({ patterns: [ { from: resolve(__dirname, 'src/assets'), to: resolve(__dirname, 'dist/assets') } ] }) ], 插件开发者可以以此为起点触达到 webpack 内部定义的任意钩子，例如： class SomePlugin { apply(compiler) { compiler.hooks.thisCompilation.tap('SomePlugin', (compilation) => { }) } } 配置拆分对配置进行拆分是为了便于在不同环境中使用不同的配置项，例如在生产环境需要生成文件的 hash 值，但是开发环境不需要，在开发环境取消 hash 命名能够加快构建的速度。 webpack 一般会分为三个配置文件：base（公共部分）、dev（开发环境）、prod（生产环境） 在调用 npm script 时传入的环境参数会被用来判断导出何种配置，如果传入的是 development，那么使用webpack-merge 插件将 base 和 dev 配置文件进行合并，然后输出；如果传入的是 production，那么将 base 和 prod 配置文件合并导出 // webpack.config.js const { merge } = require('webpack-merge'); const devConfig = require('./webpack.dev'); const prodConfig = require('./webpack.prod'); const baseConfig = { ... }; module.exports = (env) => { return env.development ? merge(baseConfig, devConfig) : merge(baseConfig, prodConfig); }; 在 package.json 文件中调用 \"scripts\": { \"start\": \"webpack-dev-server --env.development\", \"build\": \"webpack --env.production\" } 插件合集下面列举了常用的 loader 和插件合集： npm i node-sass sass fibers @babel/core @babel/preset-env @babel/preset-typescript autoprefixer cssnano css-loader sass-loader babel-loader postcss-loader file-loader --save-dev npm i webpack webpack-cli webpack-dev-server html-webpack-plugin clean-webpack-plugin copy-webpack-plugin mini-css-extract-plugin terser-webpack-plugin webpack-merge webpack-bundle-analyzer progress-bar-webpack-plugin --save-dev 基础配置// 配置遵循 CommonJS 规范 // path 用于解决不同系统下的路径差异 const { resolve } = require('path'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); const CopyPlugin = require('copy-webpack-plugin'); const { merge } = require('webpack-merge'); const devConfig = require('./webpack.dev'); const prodConfig = require('./webpack.prod'); const ProgressBarPlugin = require('progress-bar-webpack-plugin'); const baseConfig = { // 单入口配置生成 chunk 会被命名为 main // entry: \"./index.js\", // 非 SPA 应用需要配置多个入口 // 每个属性的键名会是生成的 chunk 的名称 entry: { index: './index.js' // search: \"./search.js\" }, output: { // resolve 传入路径从右至左解析，遇到第一个绝对路径是完成解析 // __dirname 则是获得当前文件所在目录的完整路径名 path: resolve(__dirname, 'dist'), // 单入口应用可以直接固定文件名 // filename: \"index.bundle.js\" // 在多入口应用中常使用 [name].bundle.js 来确保每个文件具有唯一名称 // 在 webpack.pro.js 中还会使用 [contentHash] 来生成全新的文件名 filename: '[name].bundle.js' }, // resolve 用来配置模块如何被解析 resolve: { // 设置别名，用于简化路径 alias: { // vue 需要的特殊配置 // $ 用于表示精确匹配，此时 import 'vue/index.js' 不会被解析作别名 vue$: 'vue/dist/vue.esm.browser.js' // Utilities: resolve(__dirname, 'src/utilities/'), // 原先的导入方式：import Utility from '../../utilities/utility' // 配置了别名之后可以简化为：import Utility from 'Utilities/utility'; } }, // 配置 loader module: { rules: [ // loader 自下而上执行，处理后的结果会传递给下一个 loader // test 用来筛选资源，当 test 的值为字符串时，可以为资源（或其所在目录）的绝对路径 // use 支持数组形式添加多个 loader // include 表示哪些目录的文件需要被处理 // exclude 表示哪些目录的文件不需要被处理，能够有效的加快打包速度 // test、include、exclude 都支持使用数组传入多个值 { test: /\\.(sa|sc|c)ss$/, // loader 是从右往左执行的，这里先经过 sass-loader 再到 css-loader use: [MiniCssExtractPlugin.loader, 'css-loader', 'postcss-loader', 'sass-loader'], include: resolve(__dirname, 'src'), exclude: /node_modules/ }, // use 也支持对象传入，这是为了添加格外配置 options // 自 babel7 开始，babel 已经能够识别 ts，不需要添加额外的 ts-loader { test: /\\.(js|jsx|ts|tsx)$/, use: { loader: 'babel-loader', options: { cacheDirectory: true, presets: ['@babel/preset-env', '@babel/preset-TypeScript'] } }, include: resolve(__dirname, 'src'), exclude: /node_modules/ }, // file-loader 目的是保持 css 定义的 url 属性或者 img 标签中的 src 属性在打包时的正确引用 { test: /\\.(png|svg|jpg|jpeg|gif|webp|woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ], include: resolve(__dirname, 'src'), exclude: /node_modules/ } ] }, plugins: [ // 在打包之前将指定文件夹清空，默认是 dist new CleanWebpackPlugin(), // 将 CSS 内容提取到单独文件 new MiniCssExtractPlugin(), // 会在打包结束之后自动创建一个index.html, 并将打包好的JS自动引入到这个文件中 new HtmlWebpackPlugin({ template: resolve(__dirname, 'index.html'), cache: true }), // 将素材文件拷贝到指定文件夹 new CopyPlugin({ patterns: [ { from: resolve(__dirname, 'src/assets'), to: resolve(__dirname, 'dist/assets') } ] }), new ProgressBarPlugin() ], // 用于屏蔽不必要的控制台输出 stats:{ modules: false, children: false, chunks: false, chunkModules: false } }; // 根据 npm script 传入的环境参数暴露出不同的配置 // webpack-merge 能够合并两个配置文件 module.exports = (env) => { return env.development ? merge(baseConfig, devConfig) : merge(baseConfig, prodConfig); }; 开发环境配置const { HotModuleReplacementPlugin } = require('webpack'); module.exports = { // 可选值 'none' | 'development' | 'production' // 通过 CLI 参数 --mode=production 传递，会将 process.env.NODE_ENV 设置为对应的 mode 值 mode: 'development', output: { // 取消在 bundle 中引入「所包含模块信息」的相关注释，有利于加快大型项目的构建速度 pathinfo: false }, // 生成 sourcemap 文件，便于定位错误位置，不使用 sourcemap 能够加快编译速度 devtool: 'source-map', plugins: [ // 内置热更新功能 new HotModuleReplacementPlugin(), ], // 设置本地服务器 devServer: { port: 10086, // 自动打开浏览器 open:true, // hot 开启 HMR 功能 hot: true } }; 生产环境配置const TerserPlugin = require('terser-webpack-plugin'); const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer'); module.exports = { mode: 'production', output: { filename: '[name].[contentHash].bundle.js' }, plugins: [ // bundle 包分析工具 new BundleAnalyzerPlugin() ], // optimization 优化 optimization: { // splitChunks 用于提取公共依赖模块，减轻 index.bundle.js 的大小 // chunk 默认使用 async，只提取按需加载模块，其他参数：initial（初始块）、all（全部块） splitChunks: { chunks: 'async' }, // 文件压缩 minimize: true, minimizer: [ new TerserPlugin({ // 开启缓存 cache: true }) ] } }; 编译速度优化构建打点使用 Speed Measure Plugin 插件对构建的全过程进行打点，了解每一个构建步骤的耗时，针对性的进行优化，配置也很简单，在原有的配置外使用smp.wrap包裹即可 cnpm install --save-dev speed-measure-webpack-plugin const SpeedMeasurePlugin = require(\"speed-measure-webpack-plugin\"); const smp = new SpeedMeasurePlugin(); module.exports = smp.wrap(YourWebpackConfig); 输入结果如下图： 缓存类似浏览器缓存，当目标文件已经存在的时候，就不会重复进行编译，直接读取即可，loader 中大多都有 cache 配置项。 module.exports = { module: { rules: [ { test: /\\.(js|jsx|ts|tsx)$/, use: { loader: 'babel-loader', options: { cacheDirectory: true, presets: ['@babel/preset-env', '@babel/preset-TypeScript'] } }, } ], }, }; 如果 loader 没有内置缓存，也可以使用 cache-loader ，在原有的 loader 前加上 cache-loader 即可： cnpm install --save-dev cache-loader module.exports = { module: { rules: [ { test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, 'cache-loader', 'css-loader', 'postcss-loader', 'sass-loader' ] }, ], }, }; 下面是开启了 css、babel、HtmlWebpackPlugin、TerserPlugin 缓存的耗时，相比未开启缓存快了 41% 多核打包happypack 可以获取到 cpu 的核数，榨干 cpu 的线程，加快打包速度 实现方式：将原本卸载 rules 内的 loader 移至 plugins 下的 HappyPack 函数内： cnpm install --save-dev happypack const HappyPack = require('happypack'); const os = require('os'); // 开辟一个线程池 // 拿到系统CPU的最大核数，happypack 将编译工作灌满所有线程 const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length }); module.exports = { module: { rules: [ { test: /\\.(sa|sc|c)ss$/, use: ['happypack/loader?id=css'] }, { test: /\\.(js|jsx|ts|tsx)$/, exclude: /node_modules/, use: ['happypack/loader?id=babel'], }, ], }, plugins:[ new HappyPack({ id: 'babel', threadPool: happyThreadPool, loaders: [{ loader: 'babel-loader', query: { cacheDirectory: true, presets: ['@babel/preset-env', '@babel/preset-TypeScript'] } }] }), // 可以定义多个 happypack new HappyPack({ id: 'other', threadPool: happyThreadPool, loaders: [] }), ] }; 重要：MiniCssExtractPlugin 无法与 happypack 共存，不要用 happypack 对 MiniCssExtractPlugin 进行包裹。 下面是开启了 babel 多线程的耗时，相比未开启多线程快了 8% 抽离webpack 进行抽离的方式有两种： 使用 webpack-dll-plugin 在首次构建的时候就对静态资源进行打包，后续只要引用这个已经打包好的静态资源即可，类似于预编译。 使用 externals 将静态资源进行剔除，并通过 CDN 进行加载。 两者的优缺点： webpack-dll-plugin： 因为第一次编译后就不再参与编译，需要手动去维护，容易出现版本错误； 插件会将静态资源打包成一份文件，虽然减少了请求数量，但是单个文件会变得很大， HTTP2 多路复用特性更适合碎片化的小文件。 external：极度依赖 CDN 资源的稳定性，如果是关键依赖资源缺失，页面会无法加载 使用 external修改 webpack 配置： module.exports = { ..., externals: { // key是我们 import 的包名，value 是CDN为我们提供的全局变量名 // 所以最后 webpack 会把一个静态资源编译成：module.export.react = window.React \"react\": \"React\", \"react-dom\": \"ReactDOM\", \"redux\": \"Redux\", \"react-router-dom\": \"ReactRouterDOM\" } } 配置好 external 属性后，就需要在 index.html 中引入 CDN 资源，例如： &lt;head&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/rxjs/6.4.0/rxjs.umd.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; 将 vue、localforage、rxjs、lodash 剥离后，打包时间缩短了 13%，但其主要的作用还是减少包的大小 优化后的配置基础配置// 配置遵循 CommonJS 规范 // path 用于解决不同系统下的路径差异 const { resolve } = require('path'); const SpeedMeasurePlugin = require('speed-measure-webpack-plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); const CopyPlugin = require('copy-webpack-plugin'); const { merge } = require('webpack-merge'); const devConfig = require('./webpack.dev'); const prodConfig = require('./webpack.prod'); const ProgressBarPlugin = require('progress-bar-webpack-plugin'); const smp = new SpeedMeasurePlugin(); const HappyPack = require('happypack'); const os = require('os'); // 开辟一个线程池 // 拿到系统CPU的最大核数，happypack 将编译工作灌满所有线程 const happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length }); const baseConfig = { // 单入口配置生成 chunk 会被命名为 main // entry: \"./index.js\", // 非 SPA 应用需要配置多个入口 // 每个属性的键名会是生成的 chunk 的名称 entry: { index: './index.js' // search: \"./search.js\" }, output: { // resolve 传入路径从右至左解析，遇到第一个绝对路径是完成解析 // __dirname 则是获得当前文件所在目录的完整路径名 path: resolve(__dirname, 'dist'), // 单入口应用可以直接固定文件名 // filename: \"index.bundle.js\" // 在多入口应用中常使用 [name].bundle.js 来确保每个文件具有唯一名称 // 在 webpack.pro.js 中还会使用 [contentHash] 来生成全新的文件名 filename: '[name].bundle.js' }, // resolve 用来配置模块如何被解析 resolve: { // 设置别名，用于简化路径 alias: { // vue 需要的特殊配置 // $ 用于表示精确匹配，此时 import 'vue/index.js' 不会被解析作别名 // vue$: 'vue/dist/vue.esm.browser.js' // Utilities: resolve(__dirname, 'src/utilities/'), // 原先的导入方式：import Utility from '../../utilities/utility' // 配置了别名之后可以简化为：import Utility from 'Utilities/utility'; } }, // 配置 loader module: { rules: [ // loader 自下而上执行，处理后的结果会传递给下一个 loader // test 用来筛选资源，当 test 的值为字符串时，可以为资源（或其所在目录）的绝对路径 // use 支持数组形式添加多个 loader // include 表示哪些目录的文件需要被处理 // exclude 表示哪些目录的文件不需要被处理，能够有效的加快打包速度 // test、include、exclude 都支持使用数组传入多个值 { test: /\\.(sa|sc|c)ss$/, // loader 是从右往左执行的，这里先经过 sass-loader 再到 css-loader use: [MiniCssExtractPlugin.loader, 'cache-loader', 'css-loader', 'postcss-loader', 'sass-loader'], include: resolve(__dirname, 'src'), exclude: /node_modules/ }, // use 也支持对象传入，这是为了添加格外配置 options // 自 babel7 开始，babel 已经能够识别 ts，不需要添加额外的 ts-loader { test: /\\.(js|jsx|ts|tsx)$/, use: ['happypack/loader?id=babel'], include: resolve(__dirname, 'src'), exclude: /node_modules/ }, // file-loader 目的是保持 css 定义的 url 属性或者 img 标签中的 src 属性在打包时的正确引用 { test: /\\.(png|svg|jpg|jpeg|gif|webp|woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ], include: resolve(__dirname, 'src'), exclude: /node_modules/ } ] }, plugins: [ // 在打包之前将指定文件夹清空，默认是 dist new CleanWebpackPlugin(), // 将 CSS 内容提取到单独文件 new MiniCssExtractPlugin(), // 会在打包结束之后自动创建一个index.html, 并将打包好的JS自动引入到这个文件中 new HtmlWebpackPlugin({ template: resolve(__dirname, 'index.html'), cache: true }), // 将素材文件拷贝到指定文件夹 new CopyPlugin({ patterns: [ { from: resolve(__dirname, 'src/assets'), to: resolve(__dirname, 'dist/assets') } ] }), new ProgressBarPlugin(), new HappyPack({ id: 'babel', threadPool: happyThreadPool, loaders: [{ loader: 'babel-loader', query: { cacheDirectory: true, presets: ['@babel/preset-env', '@babel/preset-TypeScript'] } }] }) ], // 用于屏蔽不必要的控制台输出 stats: { modules: false, children: false, chunks: false, chunkModules: false } }; // 根据 npm script 传入的环境参数暴露出不同的配置 // webpack-merge 能够合并两个配置文件 module.exports = (env) => { return smp.wrap(env.development ? merge(baseConfig, devConfig) : merge(baseConfig, prodConfig)); }; 开发环境const { HotModuleReplacementPlugin } = require('webpack'); module.exports = { // 可选值 'none' | 'development' | 'production' // 通过 CLI 参数 --mode=production 传递，会将 process.env.NODE_ENV 设置为对应的 mode 值 mode: 'development', output: { // 取消在 bundle 中引入「所包含模块信息」的相关注释，有利于加快大型项目的构建速度 pathinfo: false }, // 生成 sourcemap 文件，便于定位错误位置，不使用 sourcemap 能够加快编译速度 devtool: 'source-map', plugins: [ // 内置热更新功能 new HotModuleReplacementPlugin(), ], // 设置本地服务器 devServer: { port: 10086, // 自动打开浏览器 open:true, // hot 开启 HMR 功能 hot: true } }; 生产环境const TerserPlugin = require('terser-webpack-plugin'); const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer'); module.exports = { mode: 'production', output: { filename: '[name].[contentHash].bundle.js' }, plugins: [ // bundle 包分析工具 new BundleAnalyzerPlugin() ], // optimization 优化 optimization: { // splitChunks 用于提取公共依赖模块，减轻 index.bundle.js 的大小 // chunk 默认使用 async，只提取按需加载模块，其他参数：initial（初始块）、all（全部块） splitChunks: { chunks: 'async' }, // 文件压缩 minimize: true, minimizer: [ new TerserPlugin({ // 开启缓存 cache: true }) ] } }; webpack 常见的坑使用 yarn link 或者 npm link 进行开发时，可能会出现以下报错： ReactJS: How to handle Invalid Hook Call Warning “Uncaught Error: Invalid hook call. Hooks can only be called inside of the body of a function component” in ReactJS 这是由于存在多个 react 版本所造成的，如果两个项目引用同一个 react 即可解决，所以在使用 link 库的项目的 webpack.config.js 中设置 alias： alias: { react: path.resolve(\"./node_modules/react\") } 此时报错就消失了","link":"/post/bc2a0873/"},{"title":"面试 - 面试题汇总","text":"列举了一些在面试时遇到的有价值的题目 JS部分原型题打印出的值分别是什么？ let A = function(){}; A.prototype.n = 1; let b = new A(); A.prototype = { n: 2, m: 3 }; var c = new A(); console.log(b.n); console.log(b.m); console.log(c.n); console.log(c.m); 解释：因为调用构造函数时会为实例添加一个指向最初原型（prototype）的指针，而非指向构造函数。当构造函数的原型被重写时，原来的原型依旧存在并没有被销毁，所以 b 的原型指针依然指向原来的原型，而重写之后创建的实例的原型指针会指向新的原型。 答案：1；undefined；2；3 延展 let F = function() {}; Object.prototype.a = function() { console.log('a'); }; Function.prototype.b = function() { console.log('b'); } let f = new F(); f.a(); f.b(); F.a(); F.b(); 解释：构造函数 F 继承了 Function，所以能调用 Function 上面的 b 方法，又因为 Function 继承了 Object 所以又能调用 Object 上的 a 方法，所以 F.a() 和 F.b() 分别返回 a 和 b。但当使用 new 方法创建实例时，实例 f 的 __proto__ 指向 F 的原型，而不是 F 本身，又因为原型是一个对象，所以原型继承的是 Object 而非 Function，所以实例 f 只能调用 Object上的 a 方法。不能调用 Function 上的 b 方法。 答案：a；f.b is not a function；a；b 说出下列代码的打印结果 Object.prototype.__proto__; Function.prototype.__proto__; Object.__proto__; Object instanceof Function; Function instanceof Object; Function.prototype === Function.__proto__; 答案： Object.prototype.__proto__; //null Function.prototype.__proto__; //Object.prototype Object.__proto__; //Function.prototype Object instanceof Function; //true Function instanceof Object; //true Function.prototype === Function.__proto__; //true 变量提升打印出的值分别是什么？ console.log( a ); var a = 1; 解释：var 声明会被提前到它作用域的最前面，但是他分配的值是没有提前的。 答案：undefined 延展 a(); var a = function(){ console.log('hi') }; 解释：匿名函数的情况与var一致 答案：TypeError: a is not a function a(); function a(){ console.log('hi') }; 解释：函数声明提升了函数名和函数体 答案：hi foo(); var foo = function() { console.log('foo1'); } foo(); function foo() { console.log('foo2'); } foo(); 解释：函数提升优先级高于变量提升，且变量会互相覆盖 答案：foo2、foo1、foo1 隐式转换“1”+2+”3”+4 = ？ 解释：当其他类型的值与字符串相加时（不论字符串在前还是在后），另一项都会被转义成字符串，相加的结果也必定是字符串，例如：”5” + null = 5null，”5” + undefined = 5undefined。 答案：1234 延展：”1” + + “b” = ? 解释：首先两个加号中间并不是空字符串，可以理解为：”1” + (+ “b”)，字符串b无法转换成数字类型，所以 + “b” = NaN，承接上题 “1” + NaN，NaN会被转换成字符串，所以最后的的结果是 1NaN。 答案：1NaN 拓展 乘法隐性转换原则： 1、相乘的两个数会先转换成数字类型，只要有一个数是NaN，那么结果就是NaN。 5 * “5” = 25 5 * null = 0 5 * “a” = NaN 5 * undefined = NaN 2、如果Infinity与0相乘，结果是NaN。 除法隐性转换原则: 与乘法一致，增加了：0 / 0 = NaN 5 / “5” = 1 5 / “a” = NaN 5 / undefined = NaN 5 / null = Infinity 5 / 0 = Infinity 0 / 0 = NaN 减法隐性转换原则： 与乘法一致 5 - “a” = NaN 5 - undefined = NaN 5 - null = 5 5 - “” = 5 Null 的转换原则： null 在一元计算中（除了与字符串相加）都会被转换成数字0。 数组操作打印出的值分别是什么？ const clothes = ['jacket', 't-shirt']; clothes.length = 0; console.log(clothes[0]); 解释：如果赋值 length 小于数组的实际 length，则会将数组进行截断，上题 length 设置为 0 时，clothes 的值为 []。 答案：undefined 延展 const clothes = ['jacket', 't-shirt']; clothes.length = 5; console.log(clothes[4]); 解释：当 length 大于数组的实际 length 值时，会使用 undefined 进行填充。 答案：undefined for…in/offor…in 和 for…of 有什么区别？ 答案： in 是 ES5 的 API，of 是 ES6 的 API； in 用于循环遍历对象（但也可以用于循环数组，但在循环数组的时候会将原型属性和自身属性也循环出来），of 用于遍历数组（可以配合Object.keys()来循环可迭代对象）； Object.prototype.objCustom = function () {}; Array.prototype.arrCustom = function () {}; let iterable = [3, 5, 7]; iterable.foo = \"hello\"; for (let i in iterable) { console.log(i); // 0, 1, 2, \"foo\", \"arrCustom\", \"objCustom\" } for (let i of iterable) { console.log(i); // 3, 5, 7 } in 循环出的是 key，of 循环出的是 value； 变量声明定义变量时，有 var 和无 var 的区别 使用 var 去声明全局变量时，才会被挂载到全局对象上；不使用 var 去声明变量时，不论这个变量在什么位置，都会被挂载到全局对象上。举个例子： function foo(){ var a = 10 }; console.log(a) // Uncaught ReferenceError: a is not defined function foo(){ a = 10 }; console.log(a) // 10 用 var 定义的全局变量在挂载到全局对象上后，无法被删除，而无 var 定义的全局变量可以被删除： var a = 10; delete a; // false b = 10; delete b; // true let 和 var 有什么区别？ var 存在着变量提升，而 let 没有，看一道经典的变量提升和函数声明提升的面试题： var a = 99; // 全局变量a f(); // f是函数，虽然定义在调用的后面，但是函数声明会提升到作用域的顶部。 console.log(a); // a=>99, 此时是全局变量的a function f() { console.log(a); // 当前的a变量是下面变量a声明提升后，默认值undefined var a = 10; console.log(a); // a => 10 } console.log(aicoder); // 错误：Uncaught ReferenceError ... let aicoder = 'aicoder.com'; var 没有块级作用域，而 let 有； var 可以重复声明，而 let 不能； var 定义的全局变量会写入全局对象，而 let 不会； JSON写出下列方法打印出的值 console.log(JSON.parse(true)); console.log(JSON.parse(undefined)); console.log(JSON.parse(null)); \"true\" Uncaught SyntaxError: Unexpected token u in JSON at position 0 \"null\" JSON 在进行转换时，会先调用其内部的ToString方法，boolean、null、undefined 都会被转换成对应的字符串，但是 JSON 仅支持 object、array、string、number、”true”、”false”、”null” 作为其值，所以在转换 undefined 时会报错，而 null 可以正常转换为 “null” Js 的内存机制在创建字符串/对象的时候系统会自动分配内存，当它们不再被使用的时候进行释放（垃圾回收机制）。 如何判定对象不再被使用？ 现代浏览器普遍使用的是标记清除算法，将“对象是否可获得”作为判定对象是否被使用的标准。 那么什么是对象是否可获得呢？ 举个例子，现在定义一个对象： let foo = { name: 'lucy' } 此时对象{ name: 'lucy' }是可以通过指针 foo 来获得的，接下来修改 foo 的值： foo = null 那么此时，指针 foo 的指向变了，指向了对象 null，那么此时对象{ name: 'lucy' }就没有指针再指向它了，那么它也就被判定为无法被获得，会被执行垃圾回收机制。 由此延伸开来，当两个指针指向同一个对象时： let foo = { name: 'lucy' } let foo2 = foo; foo = null; 如果将其中指针 foo 移动到 null，foo2 依旧会保持指向原对象，原对象还是能够被获得，不会被回收。 链式调用如何实现类似 .slice() 形式的调用 假设现在有一个对象 A，需要给他一个 slice2 方法，那么这就相当于是给对象 A 赋予一个 slice2 的属性，但如果要适配所有的对象，那么应该是在 Object 的原型上定义一个公共的属性，如下： Object.prototype.slice2 = function(){ console.log('call slice2') }; const A = {}; A.slice2(); // call slice2 逻辑与/或写出下列代码打印出的值 [] &amp;&amp; 1; null &amp;&amp; undefined; [] || 1; null || 1; // output: 1 、null、 []、 1 当逻辑运算的操作项都是布尔值的时候，那返回值也是布尔值，当操作项非布尔值时，返回值也可能是非布尔值。 逻辑与（A &amp;&amp; B）：找到最后一个能被转换成 true 的值 逻辑或（A || B）：找到第一个能被转换成 true 的值 BOM和DOM有和区别？BOM（Browser Object Model）是浏览器对象模型，提供与浏览器交互的方法和接口。 DOM（Document Object Model）是文档对象模型，处理网页内容的方法和接口。 onInput和onChange有何区别？onInput 事件是当输入变化时被触发的事件； onChange 事件是当输入的内容改变且失去焦点时被触发的事件； 箭头函数说一下箭头函数和普通函数的区别 箭头函数没有自己的执行上下文，所以他的 this 指向的是他的父级； 箭头函数不能当做构造函数，对其使用 new 关键字会报错； 箭头函数不可以使用 arguments 对象，该对象在函数体内不存在； 箭头函数不可使用 yield 命令； 监听对象如何接听对象的属性变化？ 使用Object.defineProperty(obj, props)方法，设置一个属性的 get 和 set 属性。 举个例子： var obj={}; Object.defineProperty(obj,'name',{ get:function(){ return data; }, set:function(newValue){ data=newValue; console.log('set :',newValue); //需要触发的渲染函数写在这... } }); obj.name=\"hello\"; // 此时触发了set方法，会输出 hello 当然还可以使用 ES6 新增的 Proxy let obj = { set:function(obj, prop, value){ console.log('set :',obj, prop, value); // 输出 {} age 100 } }; let obj2 = new Proxy({}, obj); obj2.age = 100; 双向绑定实现一个简易的双向绑定（MVVM） 双向绑定即 UI 能改变数据，数据也能反过来改变 UI，一个典型的例子就是 input 输入框 &lt;input id=\"input\"/> const data = {}; const input = document.getElementById('input'); // 监听自定义数据的变化 Object.defineProperty(data, 'text', { set(value) { input.value = value; } }); // 监听用户输入的变化 input.onChange = function(e) { data.text = e.target.value; } 空闲回调说一下 requestIdleCallback 和 requestAnimationFrame requestIdleCallback：方法回调的执行的前提条件是当前浏览器处于空闲状态； requestAnimationFrame：每一帧都会调用一次回调方法； 页面的内容都是一帧一帧绘制出来的，目前浏览器大多是 60Hz（60帧/s），每一帧耗时也就是在 16.6ms 左右。那么在这一帧的过程中浏览器又干了些什么呢？ 通过上面这张图可以清楚的知道，浏览器一帧会经过下面这几个过程： 接受输入事件 执行事件回调 开始一帧 执行 RAF (RequestAnimationFrame) 页面布局，样式计算 绘制渲染 执行 RIC (RequestIdelCallback) 这一步不是每一帧结束都会执行，只有在一帧的 16.6ms 中做完了前面 6 件事儿且还有剩余时间，才会执行。如果一帧执行结束后还有时间执行 RIC 事件，那么下一帧需要在事件执行结束才能继续渲染，所以 RIC 执行不要超过 30ms，如果长时间不将控制权交还给浏览器，会影响下一帧的渲染，导致页面出现卡顿和事件响应不及时 属性名表达式说出下列代码打印的值 let a = {a: 10}; let b = {b: 10}; let obj = { a: 10 }; obj[b] = 20; console.log(obj[a]); 打印的结果是 20 对于属性名表达式，如果键名是一个对象的话，那么会自动转成[object Object]字符串，所以最后 obj 对象的结构为{a:10,'[object Object]':20}，而 a 也是对象，所以最后的结果是 20 React部分手写 useState下面是 useState 的伪代码： let memorizedState = [] // 存放 hooks let cursor = 0 // 在重新xuan'ran的时候需重置为 0 function useState(intialState) { memorizedState[cursor] = memeorizedState[cursor] || initialState // 获取重新渲染之前的值，如果没有则使用默认值 const currentCursor = cursor; // 闭包会记住当前的cursor function setState(newState) { memorizedState[currentCursor] = newState render() } return [ memorizedState[cursor++], setState] } 这里存在 memorizedState 数组的原因是，一个页面里面可能存在多个 useState，在调用的时候通过 cursor 去获取当前的 state CSS 部分消除空隙两个设置了display:inline-block的元素中间常常会有一段空隙，如何去消除这段空隙？ 方案一： 空隙其实是代码中的空格或者换行符导致的，所以最快捷的方式是清除这些空格，除了手动删除空格外还可以通过编译时的压缩代码来实现。 &lt;span>&lt;/span> &lt;span>&lt;/span> // 修改为 &lt;span>&lt;/span>&lt;span>&lt;/span> 方案二： 既然将空格视作字符，那么设置他的父级的字体大小为0，那么空格就不占空间了。 高度自适应一个高度自适应的 div 内有两个div，一个高度100px，希望另一个填满剩下的高度，有哪些方案？ 方案一：使用计算属性 .autoHeight{ height:calc(100% - 100px) }; 方案二：使用弹性布局 .container{ display:flex; flex-direction:column }; .autoHeight{ flex:1 }; 方案三：使用绝对定位 .container{ position:relative }; .autoHeight{ position:absolute; top:100px; bottom:0 } 浏览器部分defer &amp; async解释一下 script 标签中 defer 和 async 的区别 首先来看一下没有加任何属性的 script 标签的加载和运行过程，绿色代表的是解析 HTML，灰色代表 HTML 解析暂停，蓝色代表加载脚本，红色代表运行脚本。 可以看到默认模式下，如果遇到了脚本，会立即暂停后续 HTML 的解析并开始加载脚本，脚本加载完成之后立即运行。 而添加了 async 属性后，脚本的加载不会暂停 HTML 的解析，且和默认模式下一样，加载完成后立即运行脚本，但是他不会按照代码的书写顺序来执行代码。 最后是添加了 defer 属性，他也是异步的，不会阻塞 HTML 的解析，且会在所有 HTML 解析完成之后再运行脚本。 使用原则： 如果当前脚本不依赖其他脚本，则使用 async； 如果当前脚本依赖其他脚本或者被其他脚本依赖，则使用 defer； 如果脚本较小且被其他脚本所以来，则不适用任何属性； 除此之外还有设置了type=&quot;module&quot;属性的 script 标签，如下图所示： 为什么说DOM操作耗时？ 线程切换：浏览器为了避免渲染引擎和 JS 引擎同时修改页面而造成渲染结果不一致的情况，要求同一时间只能运行一个引擎，引擎在切换的时候会占用时间； 重新渲染：如果在操作 DOM 时涉及到元素、样式的修改，会引起浏览器的重排和重绘； 如何判断页面已经加载完毕？ window.onload 事件触发代表页面中的 DOM、CSS、JS、图片已经全部加载完毕。 window.onload = function() {}; DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载 document.addEventListener(\"DOMContentLoaded\", ready); GET&amp;POST请求有什么区别？ GET 请求在浏览器回退和刷新时是无害的，而 POST 请求会告知用户数据会被重新提交； GET 请求可以被缓存，POST 请求不可以被缓存，除非在响应头中包含合适的 Cache-Control/Expires 字段； GET 请求一般不具有请求体，因此只能进行 url 编码且有长度限制，而 POST 请求支持多种编码方式且无长度限制。 GET 请求的安全性较差，数据被暴露在浏览器的URL中，POST请求的安全性较好，数据不会暴露在URL中；","link":"/post/47814/"},{"title":"浏览器 - XSS 和 CSRF 的原理和对策","text":"前端常见的攻击方式及应对策略 XSS跨站脚本攻击（Cross Site Scripting）主要有反射型和存储型两种。 反射型XSS 代码在 url 中，读取含有恶意脚本的 url 参数并渲染至模板，脚本会在浏览器解析过程中运行。 举个例子： URL:localhost:8080?id=&lt;script&gt;alert('xss')&lt;/script&gt;100 &lt;div> My Account: {query.id} &lt;/div> 当访问上述网址时，参数能够正常显示，但同时也会弹出 xss 的提示框，表示已经注入成功。 还有一类便是通过溢出 Html 元素属性来实现，举个例子： URL:localhost:8080?imgpath=ABCD&quot; onclick=&quot;alert('xss')&quot; &lt;img src=\"{query.imgpath}\"/> 这时候实际渲染出的是： &lt;img src=\"ABCD\" onclick=\"alert('xss')\" /> 通过增加双引号关闭了 src 属性，然后添加自定义的属性，当点击该图片时就会触发脚本。 最省事的解决方式：将 url 参数转义为 JSON 字符串 存储型XSS 代码存储在后端，从后端取数据时，会将带有恶意脚本的数据渲染至模板，导致脚本的运行。 解决方案：对用户输入进行白名单过滤，可使用现有 js-xss 库，在存储用户输入时进行过滤而非渲染时过滤能够减少不必要的性能损耗。 CSRF跨站请求伪造（Cross Site Request Forgy），在 B 站发起对 A 站的请求，如果用户已经在 A 站登录，那么请求会带上 A 站的 Cookie，那么这个请求就会被判定是 A 站用户的正常操作。 举个例子： A 站的转账请求格式如下 https://a.com?userid=*&amp;amount=* B 站的页面如下 &lt;img src='https://a.com?userid=100&amp;amount=200' /> 访问 B 页面时会直接提交 A 站的转账请求，用户的存款就被转走了。 解决 CSRF 的方案主要有以下几种方式： sameSite属性cookie 增加了 samesite 属性，将其设置为 Lax 或者 Strict 都能够防止跨站读取 Cookie。 同源检测Http 头中含有 referer 和 Origin 字段用来记录发出请求的地址，如果判断 referer 或 origin 的值合法，那么大概率没有被伪造，但也不可以确信，因为浏览器可能被修改或不支持。 验证码校验CSRF 特点便是不在主站页面上运行，通过在页面设置验证码并要求用户输入，可以避免跨站的请求伪造。 设置 tokentoken 是简化版的验证码，先由后端生成由时间戳和随机数组成的 token 并保存在 session 中，然后传递给页面，页面将 token 添加至请求数据中，后端收到数据时，取出 token 并与 session 中的 token 进行比对，如果一致且没有超过有效期限，则说明没有被伪造。","link":"/post/60b1c43/"},{"title":"React HOC 高阶组件","text":"高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。 具体而言，高阶组件是参数为组件，返回值为新组件的函数。 实现方式属性代理返回用函数包裹原组件生成新组件，可以看做是被代理组件的父组件： // proxyHOC.jsx // hoc const proxyHOC = (WrappedComponent) { // 继承的是 React.Component return class extends Component { render() { return &lt;WrappedComponent {...this.props} />; } } } // TestComponent.jsx // 原组件 class TestComponent extends Component{ ... } // 生成新组件 const TestWithHoc = proxyHOC(TestComponent); // 将生成的新组件暴露出去 export default TestWithHoc 反向继承返回一个继承原组件的新组件，因为是直接继承，所以可以访问到原组件的生命周期、props、state 以及 render 函数： const inheritHOC = (WrappedComponent) { // 继承的是原组件 return class extends WrappedComponent { render() { // super 关键字用于访问和调用一个对象的父对象上的函数 return super.render(); } } } 实现了什么功能操作 props在 HOC 内部可以对传递过来的 props 进行修改，再传给新组件： const proxyHOC = (WrappedComponent) { return class extends Component { render() { // 对 props 进行改造 const newProps = { ...this.props, name:'Test' } return &lt;WrappedComponent {...this.newProps} />; } } } 获得 refs 的引用在 HOC 内部，可以获取到新组件的 ref： import React,{ Component, createRef } from 'react'; const proxyHOC = (WrappedComponent) => { return class extends Component{ constructor(props) { super(props); this.ref = React.createRef(); } render(){ return ( &lt;WrappedComponent {...this.props} ref={this.ref} /> ) } } } 传递 ref 属性ref 属性不属于 props，无法通过 props 向下传递（这里需要注意，不是 React.createRef 创造的值不能被传递，是 ref 这个属性无法被传递），举个例子： // Parent.jsx class Parent extends Component { constructor(props) { super(props); this.ref = React.createRef(); } render() { return &lt;Child ref={this.ref} data={'abc'}>&lt;/Child>; } } // Child.jsx class Child extends Component { constructor(props) { super(props); } render() { return &lt;div>{ console.log(this.props) }&lt;/div>; } } // output: { data:abc } 可以看到，并没有打印出 ref，可见 ref 并没有通过 props 被传递下去，因为 ref 不是 prop 属性，就像 key 一样，被 React 做了特殊的处理（不论是 function Component 还是 Class Component）。 而且，当 ref 指向高阶组件生成的新组件时，ref 其实指向的是高阶组件，举个例子： // childplay.js const ChildPlay = play(Child); export default ChildPlay; // another.js &lt;ChildPlay ref={this.ref}> 上面返回了 ChildPlay 组件，当我们对其 ref 赋值的时候，ref 实际上是指向了 play 而不是内部的 Child 组件，这意味着不能使用 ref.current.playMusic()这样的方法。 解决这个问题，可以使用forwardRef明确地将 ref 转发到内部的 Child 组件中去： // Child.jsx class Child extends Component { constructor(props) { super(props); } render() { return &lt;div className={\"child\"}>{console.log(this.props)}&lt;/div>; } } const ChildPlay = play(Child); // 用hoc包裹Child组件 export default ChildPlay; // playHoc.jsx export const play = (WrappedComponent) => { class InnerPlay extends Component { render() { const {forwardedRef,...props} = this.props; return &lt;WrappedComponent ref={forwardedRef} {...props} />; } } return React.forwardRef((props,ref)=>{ // forwardRef方法获取的就是传递过来的ref属性 return &lt;InnerPlay forwardedRef={ref} {...props}/> }) }; 上面高阶函数和最基础的高阶函数区别在于： 他不直接返回类组件，而是先创建一个内部的组件（InnerPlay）； 然后调用React.forwardRef()，并在该方法中，将父组件（Parent）传递过来的 ref 以 props 的形式传递给 InnerPlay； 再将 ref 通过 forwardedRef 赋值给 InnerPlay 组件的 props ； 最后 InnerPlay 组件将 forwardedRef 取出赋给目标组件的 ref 属性； 经过这样的操作，Parent 就能通过 ref 获取到 Child 组件了。 抽象state即：将不受控组件转换为受控组件，举个例子： class WrappedComponent extends Component { render() { return &lt;input name=\"name\" {...this.props.name} />; } } const proxyHOC = (WrappedComponent) => { return class extends Component { constructor(props) { super(props); this.state = { name: '', }; this.onNameChange = this.onNameChange.bind(this); } onNameChange(event) { this.setState({ name: event.target.value, }) } render() { const newProps = { name: { value: this.state.name, onChange: this.onNameChange, }, } return &lt;WrappedComponent {...this.props} {...newProps} />; } } } 用其他元素包装组件在 render 中可以在组件外添加额外的元素，常用来增加布局和修改样式： const proxyHOC = (WrappedComponent) =>{ return class extends Component{ render(){ return ( &lt;div> &lt;WrapperComponent {...this.props}>&lt;/WrapperComponent> &lt;/div> ) } } } 渲染劫持举个例子： function withAuth(WrappedComponent) { return class extends WrappedComponent { render() { if (this.props.loggedIn) { return super.render(); } else { return null; } } } } 解决什么实际问题逻辑复用需要被复用的逻辑形成高阶函数，包裹目标组件，解决代码复用问题。例如常见的日志记录： const logHoc = (WrappedComponent) { return class extends Component { componentDidCatch(error,info){ // 对错误做出响应 } render() { return &lt;WrappedComponent {...this.props} /> } } } 权限控制根据用户的权限，显示或隐藏具体内容 const auth = (WrappedComponent) { return class extends Component { render() { // 判断用户是否具有权限 if( !hasPermission ) return null; return &lt;WrappedComponent {...props} />; } } } 注意 HOC 不会也不应该去修改组件，它会生成一个新的组件，对原组件没有副作用； 不要在 render 方法中调用 HOC，因为每次调用 render 时都会生成一个新的组件，会在 diff 的时候被销毁： render() { // 每次调用 render 函数都会创建一个新的 EnhancedComponent const EnhancedComponent = enhance(MyComponent); // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！ return &lt;EnhancedComponent />; } HOC 不会复制组件的静态方法，需要手动拷贝，举个例子： // 定义静态函数 WrappedComponent.staticMethod = function() {/*...*/} // 现在使用 HOC const EnhancedComponent = enhance(WrappedComponent); // 增强组件没有 staticMethod typeof EnhancedComponent.staticMethod === 'undefined' // true hoist-non-react-statics 库能够帮助我们批量拷贝静态方法。 为了在开发与调试时更好地区分 HOC，推荐设置 HOC 的显示名称： const HOC = (WrappedComponent) =>{ return class extends Component{ static displayName = `HOC(${WrappedComponent.displayName || WrappedComponent.name || 'Component'})`; render(){ return &lt;WrapperComponent {...this.props} data={'ABC'}>&lt;/WrapperComponent> } } } 传参HOC 可以传递组件和其他参数，常用的是 HOC(…params)(WrappedComponent)的形式，Redux 的 connect 、AntDesign 的 Form.Create 采用的都是这种形式： // connect 是一个函数，它的返回值为另外一个函数。 const enhance = connect(selector, actions); // 返回值为 HOC，它会返回已经连接 Redux store 的组件 const ConnectedComment = enhance(CommentList); 要使用此形式，需要将 HOC 稍微改写一下： function HOC = (...params) => (WrappedCompoennt) =>{ ... }","link":"/post/515414f9/"},{"title":"浏览器 - Cookie基础","text":"Cookie 基础知识 概述由于 HTTP 是无状态协议，在 localstorage 和 sessionStorage 出现之前 cookie 是存储状态的唯一方式，每一次 HTTP 的请求都会带上 cookie。 什么是 cookie？ cookie 是 document 对象上的一段由键值对构成的字符串，最大字节长度为 4KB，每个域至多20个 cookie，cookie 的格式如下： &lt;cookie-name&gt;=&lt;cookie-value&gt;;&lt;cookie-name&gt;=&lt;cookie-value&gt; cookie、localStorage 和 sessionStorage 有什么区别？ 容量不同：cookie 最多可储存 4KB 的内容，storage 可以储存 5至10MB 的内容； 有效期不同：cookie 在过期时间之前一直有效，localStorage 除非主动删除否则一直有效，sessionStorage 在当前页面关闭前有效； 构成 属性 说明 domain 指定哪些域名可以访问该 cookie，默认为 origin（当前域名），不包含子域名，如果手动设置 domain 为 .google.com，则包含其子域名（大多数浏览器域名前不加点号也包含其子域名） path 指定同源域名下的哪些路径可以访问该 cookie，当设置 path 为 /goods时，/goods和/goods/apple都可访问 cookie samesite samesite 用于限制跨站读取 cookie，防止CSRF攻击，他有三个值：none、strict、laxnone：同站和跨站都会发送 cookiestrict：只在同站时会发送 cookielax：默认值，处于同站时会发送，某些条件下跨站也会发送 cookie（点击页面 a 标签跳转、js 进行页面跳转/新开页、Get请求提交表单） secure 是否只在 https 协议下传输，值为 true | false httponly 是否只允许通过 http 传输，不允许 js 获取到 cookie expires cookie 过期时间，他的值是 UTC 时间，可以通过Date.prototype.toUTCString()方法将 Date 对象转换成 UTC 字符串 max-age 从此刻开始 cookie 存活的秒数，max-age 的优先级高于 expires。如果响应头的 set-Cookie 字段没有指定 expires 和 max-age，那么返回的 cookie 只会在本次对话存在，关闭页面后 cookie 将会消失 操作 Cookie服务端服务器可以设置响应头的 Set-Cookie 字段，浏览器接受到服务器的响应后会自动设置 cookie。 举个例子： Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; JS这里整理了一个用于修改 cookie 的类： class Cookix { // 判断查找项是否存在 static has(name: string) { return new RegExp(`(^| )${name}=([^;]*)`).test(document.cookie) &amp;&amp; Cookix.get(name) !== \"\"; } // 获取查找项的值 static get(name: string) { const _match = document.cookie.match(new RegExp(`(^| )${name}=([^;]*)`)); if (!_match) return null; return _match[2]; } // 新增/替换新的cookie static set( name: string, options: { value: string; domain?: string; path?: string; maxAge?: number; expires?: string; samesite?: string; secure?: boolean; } ) { const defaultOptions = { domain: \"\", path: \"/\", maxAge: \"\", expires: \"\", samesite: \"lax\", }; const optionsClone: { [key: string]: string | number | boolean } = { ...defaultOptions, ...options }; const optionArray = Object.keys(optionsClone); let optionStr = optionArray .filter((item) => item !== \"value\" &amp;&amp; optionsClone[item] !== \"\") .map((key: string) => `${key}=${optionsClone[key]}`) .join(\";\"); optionStr += optionsClone.secure ? \";secure;\" : \";\"; document.cookie = `${name}=${options.value};${optionStr}`; } // 删除指定cookie static remove(name: string, options?: { domain?: string; path?: string }) { const defaultOptions = { domain: \"\", path: \"/\", value: \"\", expires: \"Thu, 01 Jan 1970 00:00:00 UTC\", }; const _options = { ...defaultOptions, ...options }; Cookix.set(name, _options); } } export default Cookix;","link":"/post/326/"},{"title":"React Hook","text":"React Hook 的基础知识 React HooksReact Hook 是用来实现逻辑的复用的加强版的函数组件，使用 hook 实现逻辑复用可以避免使用 render props 和 高阶组件多次嵌套形成的“嵌套地狱”。 优点 React 高阶组件造成的嵌套地狱是指当使用多个高阶组件包装一个组件时，会产生很多层级的容器组件，导致代码可读性和维护性降低，例如，如果一个组件被这样包装： export default withSubscription(withMouse(withCat(WrappedComponent))); 那么在 React Developer Tools 中，它的显示名称可能是这样的： &lt;WithSubscription> &lt;WithMouse> &lt;WithCat> &lt;WrappedComponent /> &lt;/WithCat> &lt;/WithMouse> &lt;/WithSubscription> 类组件复用逻辑需要用到高阶函数，高阶函数是一个黑盒，外面的组件不知道内部的组件的逻辑，层层叠加之后，会给调试带来困难，而 hook 能够抽离逻辑到组件外部，很好的解决了这个问题； 类组件因为需要创建类组件的实例，所以对性能的开销较大，函数组件开销相对较小； 相较于也是复用逻辑的 HOC，每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在render方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载。 函数组件不存在 state，但是 hook 弥补了这个缺点； 限制 不要在循环、条件判断或嵌套函数中使用（或者说初始化） Hooks，例如： if(exsit){ const [name,setName] = useState(\"\"); } 因为 Hooks 是基于闭包实现，在调用时每个 hook 都按顺序加入链表结构中，并赋予相对应的 index，在更新状态时，会根据 index 去修改 state，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。 只能在函数组件中使用 Hooks useEffectsource 参数 useEffect 包含了 componentDidMount、componentDidUpdate、componentWillUnmount 三个生命周期，区别这三个生命周期主要是靠 source 参数： useEffect(() => { console.log('componentDidMount || componentDidUpdate'); return () => { console.log('componentWillUnmount'); } }, source); 当 source 没有值的时候，相当于 componentDidUpdate，每次更新都会被调用，且先调用 return 的函数，再调用外部的函数； 当 source 为空数组时，外部函数相当于 componentDidMount，return 函数相当于 componentWillUnmount ； 当 source 有值时，相当于 componentDidUpdate，但只会在 source 数组中的值变化时才会被调用，也是先调用 return 的函数，再调用外部的函数； 回调函数 useEffect 的回调函数，是对上一次调用 useEffect 进行清理，举个例子： export default function HookTest() { const [count, setCount] = useState(0); useEffect(() => { console.log('执行...', count); return () => { console.log('清理...', count); } }, [count]); return ( &lt;div> &lt;p>You clicked {count} times&lt;/p> &lt;button onClick={() => { setCount(count + 1) }}> Click me &lt;/button> &lt;/div> ); } // output: // 执行... 0 // 清理... 0 , 执行... 1 // 清理... 1 , 执行... 2 可以看到，在发生 state 变动的时候，会先触发 return 内的函数，且 return 内的函数获取到的是之前的 state。 那么再来看一下，useEffect 和渲染的执行顺序： export default function HookTest() { const [count, setCount] = useState(0); useEffect(() => { console.log('执行...', count); return () => { console.log('清理...', count); } }, [count]); return ( &lt;div> {console.log(`render ${count}`)} &lt;p>You clicked {count} times&lt;/p> &lt;button onClick={() => { setCount(count + 1) }}> Click me &lt;/button> &lt;/div> ); } // output: // render 0 , 执行... 0 // render 1 , 清理... 0 , 执行... 1 // render 2 , 清理... 1 , 执行... 2 可以看到，render 要优先于 useEffect 触发。 useState实现累加：将函数作为值传入，可以获取到上一次修改的 state，然后返回一个更新后的值： setTranslateY(prevState => prevState + 1); useLayoutEffectuseLayoutEffect 的作用和 useEffect 类似，写法上也类似： useEffect(() => { // 执行副作用 return () => { /* clean up */} }, [dependency, arr]) useLayoutEffect(() => { // 执行副作用 return () => { /* clean up */} }, [dependency, array]) 他们的不同点在于： useEffect 是在渲染函数执行完成，并绘制到屏幕之后，再异步执行。大概流程如下： 触发渲染函数执行（改变状态，或者父组件重新渲染） React调用组件的渲染函数 屏幕中重绘完成 执行useEffect useLayoutEffect 是在渲染函数执行之后，但是屏幕重绘前同步执行。大概流程如下： 触发渲染函数执行（改变状态，或者父组件重新渲染） React调用组件的渲染函数 执行 useLayoutEffect，并且 React 会等待它执行完成 屏幕中重绘完成 useId如果应用是 CSR（客户端渲染），id 是稳定的，不需要使用该 API，但如果应用是 SSR（服务端渲染），那么App.tsx 会经历： React 在服务端渲染，生成随机id（假设为0.1234），这一步叫 dehydrate（脱水） React 在客户端渲染，生成随机id（假设为0.6789），这一步叫 hydrate（注水） 最后客户端、服务端生成的 id 会出现不匹配的情况，于是 React 18 中新增了 useId 来生成不变的 ID function Checkbox() { const id = useId(); return ( &lt;> &lt;label htmlFor={id}>Do you like React?&lt;/label> &lt;input id={id} type=\"checkbox\" name=\"react\"/> &lt;/> ); }; 它的本质是通过组件在树中的层级计算出唯一ID，如下图所示 useImperativeHandleuseImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。useImperativeHandle 应当与 forwardRef 一起使用： // child.js function FancyInput(props, ref) { const inputRef = useRef(); useImperativeHandle(ref, () => ({ focus: () => { inputRef.current.focus(); } })); return &lt;input ref={inputRef} ... />; } FancyInput = forwardRef(FancyInput); //parent.js &lt;FancyInput ref={inputRef} /> inputRef.current.focus() useTransition当函数被 startTransition 包裹时，函数 setState 触发的渲染就会被标记为不紧急渲染，有可能被其他的紧急渲染所挤占，举个例子： function App() { const [isPending, startTransition] = useTransition(); const [count, setCount] = useState(0); function handleClick() { startTransition(() => { setCount(c => c + 1); // 此处为不紧急渲染，如果有文本输入等紧急渲染任务，此渲染会被推迟 }) } return ( &lt;div> {isPending &amp;&amp; &lt;Spinner />} &lt;button onClick={handleClick}>{count}&lt;/button> &lt;/div> ); } useDeferredValue其作用于 useTransition 类似，不过 useTransition 是包装更新任务成为延迟更新任务，而 useDeferredValue 是产生一个新的值，将这个值延迟。 useDeferredValue 仅延迟你传递给它的值。如果你想要在紧急更新期间防止子组件重新渲染，则还必须使用 React.memo 或 React.useMemo 记忆该子组件： function Typeahead() { const query = useSearchQuery(''); const deferredQuery = useDeferredValue(query); // Memoizing 告诉 React 仅当 deferredQuery 改变， // 而不是 query 改变的时候才重新渲染 const suggestions = useMemo(() => &lt;SearchSuggestions query={deferredQuery} />, [deferredQuery] ); return ( &lt;> &lt;SearchInput query={query} /> &lt;Suspense fallback=\"Loading results...\"> {suggestions} &lt;/Suspense> &lt;/> ); } 自定义 Hook 实现逻辑复用自定义 hook 是 Hook 模式下实现 render props 或者高阶组件的方式，举个例子： // useSetOnlineState.jsx import { useState, useEffect } from 'react'; export const useIsOnline = (userInfo) => { const [isOnline,setIsOnline] = useState(null); useEffect(()=>{ setIsOnline( useInfo.state === 'online' ); }); return isOnline; } 上例新建了一个 useIsOnline 的 hook，根据传入的 userInfo 来判断并设置内部状态 isOnline 并将其返回，下面是该 hook 的调用方式： function UserList(props) { const isOnline = useIsOnline( userItem.userInfo ); return ( ... ); } 自定义 hook 除了可以直接返回值外，还可以返回设置默认值、内部状态的方法，这样实现的 hook 使用方法与原生 useState 相同： // useRandomColor.jsx import { useState, useEffect } from 'react'; export const useRandomColor = (initialColor) => { const [color,setColor] = useState(initialColor); const changeColor = (currentColor) =>{ setColor(currentColor); } return [ color,changeColor ]; } Hook 父组件调用子组件方法首先在父组件中引入子组件，并父给子组件一个 ref 对象： const childrenRef = useRef(null); return &lt;children ref={childrenRef} /> 然后修改子组件，给子组件套上forwardRef，然后使用useImperativeHandle暴露 ref 自定义的实例值给父组件： function children(props, ref) { useImperativeHandle(ref, () => ({ hello: () => console.log('hello world!') })) return &lt;h1>children&lt;/h1> } export default forwardRef(children); 最后在父组件中调用： const something = () => childrenRef.current.hello();","link":"/post/9adc5f11/"},{"title":"React Redux","text":"Redux 基础知识 Redux 原则 唯一数据源：Redux 应用只维护一个全局状态对象； 状态只读：不能直接修改应用的状态，必须通过 action 来实现修改； 状态改变通过纯函数完成：reducer 必须是一个纯函数，接收到 action 后也不能直接修改状态，而是要返回一个新的状态，且 reducer 不能有副作用（比如：实时获取时间戳） Redux 组成redux 主要由 3 个部分组成：action、reducer、store，一张图揭示它们之间的关系： actionaction 是 store 唯一的数据来源，通过dispatch方法传递给 store。 actionCreatoraction 是一个对象，由 type 和 data 属性组成，一般会定义一个创建 action 对象的函数并暴露出去，统一写在 actionCreators.js 内： // actionCreators.js export const getPostList = data =>({ type:'post/get_post_list', data }) actionTypes一般 action 中的 type 属性会用一个专门的文件 actionTypes.js 来管理，防止 action 和 reducer 中的 type 属性不一致，例如： // actionTypes.js export const GET_POST_LIST = \"post/get_post_list\"; export const REMOVE_FIRST_ITEM = \"post/remove_first_item\"; export const REMOVE_LAST_ITEM = \"post/remove_last_item\"; 那么上面的 getPostList 就可以修改为： import { GET_POST_LIST } from './actionTypes.js'; export const getPostList = data =>({ type: GET_POST_LIST, data }) dispatch通知 store 需要用到 dispatch方法，dispatch 可以接收 action 对象，接收后又传给了 reducer，这个过程是同步的，如果我们想要异步处理，比如：从服务器异步请求数据，单纯的 redux 是不行的，需要用到 redux-thunk 插件。 同步 dispatch： // App.jsx import { getPostList } from './actionCreators.js'; class App extends Component{ const handleClick=()=>{ this.store.dispatch( getPostList( {id:'123'} ) ); } render(){ return &lt;div onClick={handleClick}>&lt;/div> } } 异步 dispatch： // App.jsx import {demoActionFunc} from 'actionTypes'; class App extends Component{ const handleClick=()=>{ this.store.dispatch( postFilter() ); } render(){ return &lt;div onClick={handleClick}>&lt;/div> } } // actionCreators.js export const getPostList = data =>({ type:'post/get_post_list', data }) export const postFilter = () =>{ return dispatch =>{ // 先运行AJAX请求，后执行dispatch ajax().then(( res )=>{ dispatch( getPostList(res) ) }); } } reducerreducer 用于对传入的 action 根据其 type 值作出响应，然后返回一个新的 state 对象，举个例子： import * as actionTypes from \"./actionTypes\"; const defaultState = { page: 0, perPage: 10 }; export default (state = defaultState, action) => { switch(action.type){ case 'demoActionType': return ... default: return state } } 一个项目中会有多个 reducer，一般常用 combineReducer 将他们汇总起来，一并传入 createStore 方法内，用于创建 store： import { combineReducers } from 'redux'; const reducers = combineReducers({ reducer1, reducer2 }); storestore是连接 action 和 reducer 的中间人，一个应用只会存在一个 store，保存着应用的状态。 store 通过createStore(reducers,initalStore) 方法生成，下面是包含 redux-thunk 的例子： import { createStore, compose, applyMiddleware } from \"redux\"; import thunk from \"redux-thunk\"; import reducers from \"./reducers\"; const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; const store = createStore(reducer, composeEnhancers(applyMiddleware(thunk))); export default store; store 的 3 个 API： .getState() 用来访问 store 中的状态 state .dispatch(action) 用来发送更新状态意图 .subscribe(listenerFunction) 用来监听状态的变化 function handleChange() { // do something } const unsubscribe = store.subscribe(handleChange) unsubscribe() 使用示例import { connect, bindActionCreators } from \"react-redux\"; // 第二个可选参数ownProps代表组件本身的props，如果传入，则当props变化时，mapStateToPorps就会被调用 // 适合state与props有关联的时候使用 const mapStateToProps = (state, ownProps) => { return { todos: state.todos } } const mapDispatchToProps = (dispatch, ownProps) => { return bindActionCreators({ increase: action.increase, // action是import进来的actionCreators的合集对象 decrease: action.decrease }, dispatch); } // bindActionCreators()就相当于 // { // increase: (...args) => dispatch(actions.increase(...args)), // decrease: (...args) => dispatch(actions.decrease(...args)) // } const VisibleTodoList = connect( // 建立store的state与UI组件的props间的映射关系 // 如果省略mapStateToProps，那么UI组件就不会订阅store，即store的更新不会引起UI组件的更新 mapStateToProps, // 用于建立store.dispatch方法和UI组件的props间的映射关系 mapDispatchToProps )(TodoList);","link":"/post/7b0f5557/"},{"title":"浏览器 - 缓存","text":"http 缓存机制分为两种：强制缓存和协商缓存。并且在不同刷新方式下和浏览器环境下对策略的采取会有所区别。 缓存机制浏览器的缓存策略分为两种：强缓存、协商缓存。 当请求服务器资源时，浏览器会先看本地是否有缓存，如果有缓存，则根据强缓存中的 expires 和 cache-control.max-age 判断缓存是否过期，如果没有过期则直接使用，如果已过期则向服务器请求资源，服务器会根据请求头中的信息判断资源是否能够继续使用，如果文件无变化能够继续使用则返回状态码 304，否则，重新返回状态码 200 和服务器端的资源。 强缓存通过 expires 和 cache-control 两种响应头实现。 在加载资源的时候，如果被判断为未过期，则直接读取缓存，不会请求服务器，此时返回的状态是 200（from cache）。 ExpiresHTTP 1.0 标准中提出，表示资源失效时间，其值为绝对时间，如果本地的时间被修改，那么缓存可能失效。 Expires: Wed, 11 May 2018 07:20:00 GMT Cache-ControlHTTP 1.1 标准中提出，优先级高于 Expires，其值为相对时间，弥补了 Expires 受本地系统时间的影响。 Cache-Control: max-age=315360000 // 设置最大可缓存时间 Cache-Control 除了 max-age 参数外，还有： no-store：不缓存数据到本地； no-cache：在提供给本地读取之前，强制要求缓存把请求提交给原始服务器进行验证（协商缓存），其作用等同于设置了max-age=0； private：只能被单个用户缓存，不能被共享，CDN 或者代理服务器都不能缓存； public：private 取反； 协商缓存资源从服务器端下载到本地的同时携带了 Etag（资源的哈希值）和 Last-Modified（资源的最后修改时间）这两个响应头。 当某个资源的请求没有命中强缓存（超出 expires 或 cache-control 规定的期限）时，会在请求头中带上 If-None-Match（从服务端获取的 Etag）和 If-Modified-Since（从服务端获取的 Last-Modified） 这两个请求头，让服务端判断是否返回最新的文件、更新 Etag和 Last-Modified。 Etag 的权重要高于 Last-Modified，这是因为 Last-Modified 只能精确到秒，无法应对非常频繁的文件更新。 刷新页面对缓存的影响刷新页面可以分为三种： 正常操作 : 地址栏输入url 、跳转链接、前进后退等，两种缓存都有效； 手动刷新 : F5、点击刷新按钮、右击菜单刷新，仅协商缓存有效； 强制刷新 : ctrl +f5、cmd + r，两种缓存策略都无效，重新请求资源；","link":"/post/16029/"},{"title":"React 渲染","text":"React 在渲染方面的基础知识和优化方式 虚拟DOM虚拟 DOM 就是用 JS 表示的抽象化的节点树，主要是通过局部更新和合并 DOM 操作来减少浏览器 reflow 和 repaint 的次数，以此来提高 DOM 操作的效率，且可以实现跨平台的开发，下面是他工作的流程： 每次数据模型变化的时候，重新生成抽象化的节点树； 通过 Dffi 算法，计算出差异部分； 将差异部分的渲染进行批处理，渲染出真实的 DOM； Diff算法策略Diff 算法有三个步骤： tree diff 对 dom 树进行分层比较，对同一层级的节点进行比较，如果节点不存在时，就会卸载该节点及其所有子节点 component diff 判断组件的类型是否发生变化，如果发生变化（例如组件A变成了组件B），则重新渲染该组件及其子组件； 如果类型没有发生变化，则会先判断 shouldComponentUpdate 的返回值，如果为 true 则跳过虚拟 DOM 树的对比直接判断为需要被修改，如果为 false，则通过对比前后虚拟 DOM 树，判断是否需要重新渲染； element diff 对于全新的元素节点会执行插入操作； 对于已有的元素节点，根据其是否可复用，执行移动或删除操作（基于Key值） FiberReact 渲染页面的两个阶段 调度阶段（reconciliation）：在这个阶段 React 会更新数据生成新的虚拟 DOM，然后通过 Diff 算法，快速找出需要更新的元素，放到更新队列中去，得到新的更新队列。 渲染阶段（commit）：这个阶段 React 会遍历更新队列，将其所有的变更一次性更新到DOM上。 在 React16 以前，采用递归的方式创建虚拟 DOM 并进行 Diff，递归过程是不能中断的，且整个过程的 JS 计算会一直占用浏览器的主进程。如果组件树的层级很深，递归会占用线程很多时间，递归更新时间超过了16ms，用户交互就会卡顿。为了解决这个问题，React16 将递归的无法中断的更新重构为异步的可中断更新，即 Fiber。 Fiber 改变了之前 React 的组件更新机制，将一次更新过程分成多个分片，并赋予不同的优先级。 有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待重新调用。 新的架构调整的是调度阶段（commit阶段无法暂停），核心思想是任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。 何时重渲染setState 当调用 setState 进行状态修改的时候，不论新状态和旧状态是否是否相等，都会重新渲染。 但是在 hooks 组件内使用 useState 进行的状态修改时会在状态相等时会阻止其重新渲染。 props变动 当父组件传给子组件的 props 发生变动时，就会引起子组件的重新渲染。 父组件更新 当父组件发生更新时，子组件都会重新渲染 渲染优化方案React.lazy组件的动态加载方案，将组件打包成对应的 chunk，当组件被需要时，通过 script 标签来动态加载 chunk。 使用 lazy 方法，需要修改原有的 import 方式： const OtherComponent = React.lazy(() => import('./OtherComponent')); 这里需要注意的是 import 方法要求接受一个 default export 的 React 组件。 然后使用 Suspense 组件进行包裹，用于等待加载时的降级： import React, { Suspense } from 'react'; const OtherComponent = React.lazy(() => import('./OtherComponent')); function MyComponent() { return ( &lt;div> &lt;Suspense fallback={&lt;div>Loading...&lt;/div>}> &lt;OtherComponent /> &lt;/Suspense> &lt;/div> ); } shouldComponentUpdate当父组件发生重新渲染时，子组件的 render 方法也会被调用，但此时父组件传给子组件的 props 并没有发生变化，那么子组件其实不需要被重新渲染，子组件可以通过 shouldComponentUpdate方法来判断当前组件是否需要被更新。 例如，如果父组件传入的 props 中的 x 属性没有变化，子组件就不需要被更新： class MyComponent extends Component{ shouldComponentUpdate(nextProps,nextState){ if(nextProps.x === this.props.x){ return false }; return true; } } PureComponent使用PureComponent替代Component，其内部已经封装了shouldComponentUpdate的浅比较逻辑。 React.memo通过校验 Props 中的数据的内存地址是否改变来决定组件是否重新渲染组件的一种技术。 对于函数组件（FunctionComponent）可以通过React.memo()进行优化，React.memo(Component)返回一个新的组件，该组件和 PureComponent 类似，能够在 state 和 props 变化时检查新旧值是否相等再决定是否渲染。 useMemouseMemo 用来存储变量，防止计算变量的函数在页面刷新时被频繁调用。 举个例子：如果有一个函数，返回一个计算后的值，那么每次组件重新渲染的时候，都会重新触发该函数，重新计算值。如果函数内部的计算逻辑较多，且希望在想关联的变量变更时才重新计算，那就需要使用 useMemo 将值进行一个缓存。 小Tip：当同时存在 useMemo 和 useEffect ，且两者的依赖相同时，会先执行 useMemo。 useCallbackuseCallback 缓存的是函数，常用于缓存父组件通过 props 传递给子组件的函数，防止子组件进行不必要的渲染。 实际上，当组件重新渲染时，被useCallBack包裹了的函数也会被重新构建，useCallBack 的本质工作不是在依赖不变的情况下阻止函数创建，而是在依赖不变的情况下不返回新的函数地址而返回旧的函数地址。不论是否使用 useCallBack 都无法阻止组件 render 时函数的重新创建。 那么是否需要给每一个函数都加上 useCallback 呢？ 每一个被 useCallBack 的函数都将被加入 useCallBack 内部的管理队列。而当我们大量使用 useCallBack 的时候，管理队列中的函数会非常之多，任何一个使用了 useCallBack 的组件重新渲染的时候都需要去遍历 useCallBack 内部所有被管理的函数，找到需要校验依赖是否改变的函数，并进行校验。在以上这个过程中，寻找指定函数需要性能，校验也需要性能。所以，滥用 useCallBack 不但不能阻止函数重新构建还会增加不必要的负担。 同时需要注意的是：子元素需要使用React.memo进行包裹，不然不会生效。 来看一个实例：查看例子 这里有一个子组件，包含一个 input 元素，在输入时会调用父函数传递过来的 inputChange 函数，父组件会将传递过来的值保存在父组件的 value 状态中。 如果父元素不进行 value 状态的更新操作，那么子组件的 input 元素在输入的时候，不会触发父组件和子组件的重新渲染； 如果父组件设置了 value 状态的更新操作，首先父组件会触发重新渲染，直接导致子组件也进行重新渲染。 对于子组件的重新渲染，首先想到的是使用 React.memo 进行 props 的新旧判断，但结果是子组件还是会重新渲染，也就是说：props 其实发生了改变。 这也不难理解，当父组件重新渲染时，function 内的方法都会重新被调用，handleInputChange 变量会被重新分配内存指针，所以传给子组件的 props 自然就变了。 那么这时候就需要进行函数的缓存，让 props 变得稳定，防止子组件无故刷新。 List key对于列表或其他结构相同的节点，为其中的每一项增加唯一key属性，以方便React的diff算法中对该节点的复用，减少节点的创建和删除操作 渲染HTML使用dangerouslySetInnerHTML可以渲染 html 元素，但会增加被跨站脚本（XSS）攻击的风险，同时需要注意，并不是直接传入 html，而是需要用一个__html为键的对象包裹起来： function Component(props){ return &lt;div dangerouslySetInnerHTML={{_html:'&lt;span>你好&lt;/span>'}}>&lt;/div> }","link":"/post/22854/"},{"title":"React 事件机制","text":"react 并不会在该DOM元素上直接绑定事件处理器，而是实现了一套自己的事件机制，包括事件注册、事件的合成、事件执行。 自定义事件机制的动机： 抹平浏览器间的兼容性差异 改造原生事件，添加自定义属性 抽象事件机制实现跨平台开发 干预事件的分发以做到更好的优化 事件注册事件注册做了两件事：事件注册、事件存储，完整的过程如下： 拿到需要被挂载的组件，调用 createElement 得到虚拟 DOM 树； 在虚拟 DOM 进行挂载、更新时，对组件的 props 进行处理，获取事件类型和回调函数； 挂载完成后，判断是否含有事件，如果有则在 document 上完成事件注册，并存储回调函数至 listenerBank 中； V17 的改动react v17 将不再往 document 上挂事件委托，而是挂载到 root DOM 上，主要是为了： 脱离 document 更方便于跨平台开发 解决多个 React 版本共存出现问题 合成事件的阻止冒泡现在会影响到手动添加的 DOM 事件的触发，因为 root DOM 会比 document 先一步接收到事件的冒泡： document.addEventListener('click', function() { // This custom handler will no longer receive clicks // from React components that called e.stopPropagation() }); 事件合成合成事件包括：对原生事件的封装、对原生事件的改造、对不同浏览器的兼容。 封装原生事件合成事件的回调函数会接收到 SyntheticEvent 的实例，实例拥有和浏览器原生事件一样的接口，原生的浏览器事件可以通过 nativeEvent 属性来获得 改造原生事件react并不是只处理你声明的事件类型，还会额外的增加一些其他的事件，帮助我们提升交互的体验。 例如在绑定 onChange 事件后，react 会在 SyntheticEvent 实例中额外注册 invalid 事件。 兼容浏览器例如 react 在绑定事件方面对 ie8 及早期版本进行兼容，使用 target.attachEvent()替换target.addEventListener() 事件执行事件执行的主要步骤： 事件冒泡到 document； 执行统一的事件分发函数 dispatchEvent； 找到当前事件对应的 ReactDOMComponent 对象； 进行事件的合成； 批量处理合成事件内的回调事件；","link":"/post/6a997138/"},{"title":"React 知识点","text":"React 基础知识点综合 React 和 Vue 的区别相同点： 数据驱动视图：从直接操作DOM到数据驱动视图 组件化：将页面分成细碎的组件，组件之间的组合嵌套就形成最后的页面 虚拟DOM 不同点： 响应式原理 Vue 提供的是反应式的数据，Vue 会遍历 data 数据对象，为每一个属性都设置 getter（访问属性时会调用该函数） 和 setter（修改属性时会调用该函数），这样就能清楚的知道哪些属性在变动。当属性值发生变动的时候，寻找所有使用到该属性的组件，重新渲染该组件。 而 React 则是需要给系统一个明确的信号（setState）来告诉系统重新渲染界面，系统在接受到指令后会使用 Diff 算法对虚拟 DOM 进行比较，计算出需要更新的部分，然后进行部分渲染。 写法差异：React all in js，Vue推荐使用 template 单文件组件格式 Diff算法不同 数据流单向数据流：数据从父组件流向子组件，子组件的数据更新的请求必须发送到父组件，让父组件作出相应的更改，再将数据传递给子组件，即子组件不能自行修改父组件传递过来的数据。 双向数据绑定：就是 UI 行为改变 Modal 层的数据，Modal 层的数据能够即时反映到 UI 上，同时在 Modal 层修改的数据（即不通过 UI 行为触发）也能够反应到 UI 上。 JSXJSX 语法实际上是 React.createElement(component,props,...children)的语法糖，所有的 JSX 语法都会被转换成这个方法调用，举个例子： const element = &lt;div className='foo'>Hello, React&lt;/div> // 等价于 const elemnt = React.createElement( 'div', { className:'foo' }, 'Hello,React' ); 在编译时 Babel 读取代码并解析，生成 AST，再将 AST 传入插件层进行转换，在转换时就可以将 JSX 的结构转换为 React.createElement 的函数。 Render组件是 React 的核心，将组件挂载到页面的 DOM 节点中需要使用 react-dom 库中的ReactDOM.render()方法： // index.js import React from \"react\"; import ReactDOM from \"react-dom\"; import App from \"./App\"; ReactDOM.render(&lt;App />, document.getElementById(\"root\")); render 方法可以返回单个元素、数组和字符串（16.0+），这样就不需要在多个元素外再包裹一个 div 了； 数组： class PostList extends Component { render() { return [ &lt;li key=\"A\">First item&lt;/li>, &lt;li key=\"B\">Second item&lt;/li>, &lt;li key=\"C\">Third item&lt;/li> ]; } } 字符串： class StringComponent extends Component { render() { return \"Just a strings\"; } } 生命周期react 的生命周期有： constructor用于初始化 state render负责返回组件 componentDidMount在组件被挂载之后触发，且只会触发一次，推荐在这里调用 Ajax 请求获取服务端数据 需要注意的是：当所有子元素都被加载完成之后，才会触发父元素的 componentDidMount 事件 shouldComponentUpdate组件更新之前触发，常用与减少组件不必要的更新，举个例子： shouldComponentUpdate(nextProps, nextState){ if(nextState.Number === this.state.Number){ return false // 如果state中前后number的值不变则不更新组件 } } componentDidUpdate组件更新之后触发 componentWillUnmount组件被卸载之前触发 完整生命周期（16.4）图示： componentDidCatch错误边界的作用：在 react 16 之后，任何未被错误边界包裹的错误都会导致整个React树被卸载。 如果一个 class 组件设置了static getDerivedStateFromError()或 componentDidCatch(error,errorInfo)中的一个或者两个，那么这个组件就会成为一个错误边界组件，当子组件错误发生时，作为父级的错误边界组件就能够获取到错误并作出对应的操作。 getDerivedStateFromError 用于在发生错误的时候修改 state 以显示错误信息或降级内容 componentDidCatch 用于在发生错误的时候对错误作出相应的操作 举个例子： // 创建一个 ErrorBoundary 组件 class ErrorBoundary extends Component{ constructor(props){ super(props); this.state={ hasError:false } } static getDerivedStateFromError(){ return { hasError:true } } componentDidCatch(error,errorInfo){ logErrorToMyService(error, errorInfo); } render() { return this.state.hasError ? ( // 当出现错误的时候显示提示 &lt;h1>Oops, something went wrong!&lt;/h1> ) : ( this.props.children ); } } 用错误边界将可能发生错误的组件包裹起来，这样就能捕获到子组件的错误信息了： class App extends Component{ render(){ return ( &lt;ErrorBoundary> &lt;Something>&lt;/Something> &lt;/ErrorBoundary> ); } } 不过错误边界能够捕获到的错误是有限的，只能捕获渲染期间、生命周期内的和组件构造函数内的错误，但是事件处理器（例如 onClick）内的、定时器内的、错误边界组件自身的错误无法被捕获。这些无法被捕获的错误可以通过try/catch来捕获。 组件分类类组件（Class Component）：传统的组件，继承于 React.Component class App extends React.Component{ ... } 纯函数组件（PureComponent）：由 React 自行管理 shouldComponentUpdate 的 Component。 对于传统组件来说，一旦 state 或 props 发生了变化，组件默认会被重新渲染，当然你也可以通过 shouldComponentUpdate 来对 state 和 props 进行对比，手动控制组件的更新。 pureComponent 简化了这个过程，由 React 自行管理，对比没有设置 shouldComponentUpdate 的传统组件性能上有一定程度上的提升。 函数组件（Function component）：函数式组件，指只需要处理 props 不需要拥有 state 的组件，举个例子： function App(){ return &lt;div>...&lt;/div> } Function component 的终极形式：React Hook 有状态组件和无状态组件组件可以根据 state 的有无分为有状态组件和无状态组件，无状态组件一般使用函数组件，常用于展示数据和通知父元素，举个例子： function PostItem(props){ const { handleClick,postContent } = props; return &lt;div onClick={ handleClick }>{ postContent.title }&lt;/div> } 受控组件与非受控组件受控组件：将表单元素的值交给 react 管理，通过 state 和 onChange 事件来修改 value 值； 非受控组件：通过操作表单元素的 DOM 来修改 value 值。 非受控组件因为值不由 react 管理，当我们需要获取该表单元素值的时候，就需要用到 ref，React.createRef()方法能够创建 Refs 并通过 ref 属性联系到 react 组件或 DOM 元素。 举个例子： import React,{ Component, createRef } from 'react'; class Login extends Component{ constructor(props){ super(props) this.state = { account:'' } this.account = createRef(); } handleSubmit=()=>{ console.log(this.account.value) } render(){ // 将input元素赋给 this.account，之后便可在其他地方通过 this.account 调用该元素 return &lt;input type='text' ref={this.account}/> } } 注意： 如果要给非受控组件赋予初始值，需要使用defaultValue或者defaultChecked属性，不能设置value属性; 只能为类组件定义 ref 属性，函数组件不支持 ref 属性（函数组件内部可以使用 ref 属性）; 类组件的 this在组件中调用方法时，this 默认不指向当前类，此时函数内获取到的 this 为 undefined，举个例子： class PostList extends Component { handleClick() { console.log(this); // undefined } render() { return &lt;div onClick={this.handleClick}>Click Me&lt;/div>; } } 绑定 this 主要有以下三种方法： 在回调中绑定： &lt;button onClick={this.deleteRow.bind(this)}>Delete Row&lt;/button> 在构造函数中绑定： constructor(props) { super(props); this.handleClick = this.handleClick.bind(this); } render(){ return( &lt;button onClick={this.handleClick}>Delete Row&lt;/button> ) } 回调使用箭头函数： &lt;button onClick={()=>{this.deleteRow()}}>Delete Row&lt;/button> 使用箭头函数进行属性初始化： class PostList extends Component { handleClick=()=>{ console.log(this); } render() { return &lt;div onClick={this.handleClick}>Click Me&lt;/div>; } } 组件间的通信父子之间父组件通过 props 向子组件传递数据，子组件通过调用父组件传递过来的 props 里面的回调函数向父组件传递数据。 兄弟之间通过一父多子（多个父子间通信结合）的方式实现，将共同的父组件作为中转来实现通信。 多层级组件之间使用 Context 来处理不同层级之间的数据传递问题，避免复杂的 props 传递，常用于用户信息、主题或者首选语言。 Context 有两个主要的 API：createContext 和 Provider，createContext 用来创建 Context 对象，Provider 用来传递数据给组件，举个例子： import React,{createContext} from 'react'; class App extends Component{ const MyContext = createContext('light'); // 创建 Context 对象并设定默认值 light render(){ return ( &lt;MyContext.Provider value={'dark'}> /* Context 传递的值为 dark */ &lt;childComponent>&lt;/childComponent> &lt;/MyContext.Provider> ) } } Context 在 class 中可以使用.contextType来设置目标 Context，挂载后允许使用this.context的形式获取 Context 的值： class Child extends Component{ componentDidMount(){ console.log(this.context) } } Child.contextType = MyContext; 对于函数组件，可以使用.Consumer方法订阅到 Context，举个例子： &lt;MyContext.Consumer> {value => /* 基于 context 值进行渲染*/} &lt;/MyContext.Consumer> 在 Hook 中。只需要使用 useContext 方法即可订阅 Context： const myContext = useContext(MyContext); Context 的替代方式利用插槽直接将元素传递下去，这样就可以在父元素直接赋值： // Contacts 组件是被传递的元素 function App() { return &lt;SplitPane left={&lt;Contacts />} />; } function SplitPane(props) { return &lt;div>{props.left}&lt;/div>; // 接收并渲染传递过来的元素 } 向 props.children 传值子组件可能通过插槽（slot）的方式引入，此时父组件内子组件用props.children代替，父组件无法直接操作子组件，也无法直接传值，React.cloneElement()很好的解决了这个问题，他可以克隆出子组件，并传递参数： // parent component // old { props.children } // new {props.children &amp;&amp; React.cloneElement(props.children, {...props})} 上面的方法在只有一个子组件的时候是能够正常运行的，但是在拥有多个子组件时会发生错误，这时候就需要用到另外一个方法：React.Children.map()，他能够对子组件数组进行循环： {props.children &amp;&amp; React.Children.map(props.children, child => React.cloneElement(child, {...props}) )} 上面的代码实现了多个 React 组件的正常传值与渲染，但如果子组件不是 React 组件，例如字符串，如果依然使用React.cloneElement()就会发生错误，需要使用React.isValidElement()方法判断子组件是否为 React 组件，如果不是，则直接返回即可： {props.children &amp;&amp; React.Children.map(props.children, child => React.isValidElement(child) ? React.cloneElement(child, {...props}) : props.children )} 父组件获取子组件Ref当我们需要获取某个子组件内部的 DOM 元素的时候，可以这样将 childRef 属性通过 props 传递给子组件，子组件再将 childRef 赋给 ref，这样父组件就能取到子组件的 DOM 节点了： import React,{ Component, createRef } from 'react'; class Parent extends Component{ constructor(props){ super(props) this.childRef = createRef(); } render(){ return &lt;Child exportRef={this.childRef}>&lt;/Child> } } class Child extends Component{ constructor(props){ super(props); } render(){ return &lt;input ref={this.props.exportRef} /> } } 这里使用了 childRef 作为变量名是因为 ref 不存在与 props 内，不能通过 props 进行传递，但是换一个变量名就可以了，如果要使用变量 ref 进行传递，就需要使用到 React.forwardRef(props,ref)来实现，ref 作为第二个参数传入，那么上面的 Child 组件就应该如下改造： const Child = React.forwardRef((props,ref)=>{ render(){ return &lt;input ref={ref} /> } }) RefRef 常用于获取获取 DOM 元素或 React 组件实例，当 ref 附加在 DOM 元素上时，可以通过ref.current获取到对该节点的引用，当 ref 附加在 Class 组件上时（函数组件不可以，因为其没有实例），ref.current获取到的是组件的挂载实例。 React 在组件挂载时给current属性传入 DOM 元素（或实例），并在组件卸载时传入 null 值，ref 会在 componentDidMount 或 componentDidUpdate 生命周期钩子触发前更新。 竞态问题异步获取数据最常见的方法仍是使用 useEffect，但是useEffect会报以下错误：Effect callbacks are synchronous to prevent race conditions，问题的原因是请求结果返回的顺序不能保证一致。 举个例子，现在有一个组件当接收关键词不同时，会重新渲染组件。那么先请求关键词为 react 的文章，然后请求关键词为 vue 的文章，但关键词为 vue 的请求更先返回。请求更早但返回更晚的情况会错误地覆盖状态值 data（此时关键词是vue，但显示的是后返回react的结果），这就叫做竞态(race conditions)，查看例子 解决方法：增加一个 didCancel 的变量，来判断当前操作是否已经被取消，查看例子 React-Router&lt;a&gt; 和 Link 组件有何区别？使用 a 标签进行渲染相当于新开了一个页面，页面需要重新被渲染且有可能会有白屏闪烁，而 Link 根据 React-router 的 Diff 算法，能够实现对页面的部分刷新，避免了不必要的渲染，有更高的效率。 React 的路由是如何实现的路由需要解决两个核心问题： 如何改变URL且不刷新页面 如何监听URL的变化 Hash 常用于锚点定位，所以本身就不会引起页面的刷新，History 是一个对象，保存了当前窗口访问过的所有网址，并提供一系列的方法来进行无刷新的前进和后退。 不论是 Hash 路由还是 History 路由，都是通过监听浏览器事件来监听URL变化的，Hash 路由监听的是hashchange事件，History 路由监听的是popstate事件。 React 在侦听到路由变化后，页面不进行刷新而是进行页面的部分替换来实现路由效果 React18 新特性 React 18 默认执行批处理，原本在 promise、定时器和原生事件处理函数内的 setState 是同步的，无法被批处理，但是在 React 18 中都会被批量合并成一次处理。如果需要退出批量更新，可以使用flushSyncAPI &lt;div onClick={() => { flushSync(() => { setCount1(count => count + 1); }); }} /> 增加了新的 API：useId、useDeferredValue、useTransition 并发模式，当你使用 startTransition 或者 useDeferredValue 时就会开启并发模式，并发模式通过 fiber 实现，能将线权的控制权交还给浏览器。","link":"/post/1e2ed1bf/"},{"title":"ES6 - Class","text":"采用面向对象编程（OOP）时，需要用类（class）去描述一类对象，用来作为创建这类对象的模板，当某个对象需要在类中被创造出来时，类的构造函数就会运行来创建这个实例 构造函数ES6 之前使用构造函数的方式来生成实例对象，举个例子： function Person(name) { this.name = name; this.greeting = function() { alert('Hi! I\\'m ' + this.name + '.'); }; } 通过函数定义了一类人，这类人有 name 属性和 greeting 方法，当我们通过构造函数去创建实例时，每一个创建出来的人都会拥有这两个属性： var person = new Person('Bob'); person.name // Bob person.greeting() // Hi! I'm Bob. 类ES6 提供了类的语法糖 class，其本质上就是一个特殊的函数： class Person{ // 构造函数，通过 new 命令生成对象实例时，自动调用该方法 constructor(name){ // 定义属性 this.name = name; } // 原型方法 greeting() { alert('Hi! I\\'m ' + this.name + '.'); }; // 静态方法 static greeting2(){ alert('Hi!'); } } 子类对象可以被拓展来增加新的属性或方法，extends 用来创建子类，子类会继承父类的属性和方法： class Boy extends Person { speak(){ console.log('speaking'); } } const boy = new Boy('Blob'); boy.name // Bob boy.greeting() // Hi! I'm Bob. boy.speak() // speaking 子类的构造函数必须执行一次 super()，如果不写构造函数，则会默认添加 class Boy extends Person { constructor(){ super(); // 相当于 Person.prototype.constructor.call(this) } callGreeting(){ super.greeting(); // 可以调用父类的方法 } } getter/setter通过 getter / setter 可以改变属性的赋值和读取的行为： class Animal { constructor(name) { this.name = name; } get name() { return 'Jack'; } set name(value) { console.log('setter: ' + value); } } let a = new Animal('Kitty'); // setter: Kitty a.name = 'Tom'; // setter: Tom console.log(a.name); // Jack 静态方法/属性静态方法通过 static 修饰符修饰的方法称作静态方法，不进行实例化也能被调用，但是通过实例化的对象进行调用会报错： class Animal { static isAnimal(a) { return a instanceof Animal; } } let a = new Animal('Jack'); Animal.isAnimal(a); // true a.isAnimal(a); // TypeError: a.isAnimal is not a function 注意点： 父类的静态方法能够被子类继承。 class Foo { static classMethod() { return 'hello'; } } class Bar extends Foo {} Bar.classMethod(); // 'hello' 静态方法调用同一个类中的其他静态方法可使用this关键字。 class StaticMethodCall { static staticMethod() { return 'Static method has been called'; } static anotherStaticMethod() { return this.staticMethod() + ' from another static method'; } } console.log(StaticMethodCall.staticMethod()) // 'Static method has been called' console.log(StaticMethodCall.anotherStaticMethod()) // 'Static method has been called from another static method' 非静态方法不能使用this关键字来访问静态方法，而是需要使用类名去访问。 class StaticMethodCall { constructor() { console.log(StaticMethodCall.staticMethod()); // 'static method has been called.' console.log(this.constructor.staticMethod()); // 'static method has been called.' console.log(this.staticMethod()); // this.staticMethod is not a function } static staticMethod() { return 'static method has been called.'; } } new StaticMethodCall(); 静态属性通过 static 修饰符修饰的变量称作静态属性，和静态方法类似： class Animal { static isAnimal = true } let a = new Animal('Jack'); Animal.isAnimal; // true a.isAnimal; // undefined","link":"/post/79887ee8/"},{"title":"React State","text":"React State 相关知识 概念state 是组件的状态，在组件的构造函数 constructor 中使用 this.state={}初始化，且 state 应是不可变对象，不可直接修改（直接修改不会触发组件的更新），应该通过 this.setState()来改变 state。 同步与异步setState 是异步还是同步主要看是谁在调用它，大部分情况下是异步的，小部分情况是同步的（此说法适合 React18 之前，React 18+ setState 都是异步的）。 setState 的异步不是真的异步，setState 本身的执行过程是同步的，是 React 将多个 setState 进行合并和批量更新，导致其看起来像是异步的。 上图所示，当处于 batch update 的时候，会将组件更新推入 dirtyComponents 队列中等待执行，否则会立即执行 dirtyComponents 的队列更新，并且同步执行操作，不在进入异步队列。 异步的情况（batch update 为 true）： 在 React 代理的合成事件中调用，如 onClick、onChange 事件，这些事件都是 React 为了代理原生事件而封装出来的一整套事件机制，我们称之为合成事件。 在钩子函数（生命周期）中调用（除 componentDidUpdate 外） 同步的情况（batch update 为 false）： 在原生事件中调用，例如： class App extends React.Component{ ... componentDidMount(){ document.querySelector('#A').addEventListener('click',()=>{ this.setState({ // 这里的 setState 是同步的 }) }) } } 在setTimeout()等定时器内调用。 两个实例：实例一：请问四次输出的结果是什么？ class Test extends React.Component { state = { count: 0 }; componentDidMount() { this.setState({count: this.state.count + 1}); console.log(this.state.count); this.setState({count: this.state.count + 1}); console.log(this.state.count); setTimeout(() => { console.log(this.state.count); this.setState({count: this.state.count + 1}); console.log(this.state.count); this.setState({count: this.state.count + 1}); console.log(this.state.count); }, 0); } render() { return null; } }; 因为前两个 setState 都是异步的，所以打印出来的都是0，且每次的this.state.count都是 0 ，所以即使异步完成，最后的结果也是 1 。当碰到定时器这样的原生事件，会立即生效，所以最后打印出来的结果是0 0 1 2 3。 实例二：下面有三个按钮：default，by addEventListener 和 by setTimeout，按钮被点击时都会将 count 值加 1，只不过实现过程不一样。查看例子 default： 无任何额外操作，直接 setState； by addEventListener：设置元素的事件监听来触发 setState； by setTimeout：将 setState 用定时器进行包裹； 从打印的结果可以看到，在事件监听（原生事件）或定时器内调用时，setState 是同步的，且能立即获取到变化后的值。然而上述的规则在 Hook 组件中是不适用的，不论哪种方式都不能即时获取 state 修改结果。那 hooks 出现这种情况的原因是什么呢？来看两个例子 let timer = null; export default function Demo1() { const [count, setCount] = useState(0); useEffect(() => { timer = setInterval(() => { setCount(count); console.log(`demo1-${count}`); }, 1000); return () => { if (timer) clearInterval(timer); }; }); return null; } 上述代码每次打印出来的都是 demo1-0 const [count, setCount] = useState(0); useEffect(() => { setTimeout(() => { console.log(`demo2-${count}`); }, 1000); }, [count]); return ( &lt;div> &lt;p>You clicked {count} times&lt;/p> &lt;button onClick={() => setCount(count + 1)}>Click me&lt;/button> &lt;/div> ); 点击后打印出来的结果是 demo2-1、 demo2-2、 demo2-3 得到一个结论，hooks 在每次重新渲染的时候都会产生一个快照，state 的值都指向这个快照（相关知识：Capture Value），闭包是出现这种情况的原因，看个例子就能理解了： function foo(increment){ let counter = 0; function child(){ counter += increment; console.log(counter); const msg = `counter is ${counter}`; return function inner(){ console.log(msg); } } return child; } const _child = foo(1); const _inner = _child(); // 1 _child(); // 2 _child(); // 3 _inner(); // counter is 1 解决异步副作用有两种方式： 使用 Ref 来存储需要实时变化的值（但是这样值的变化不会通知页面重新渲染）； setState 是异步的，所以不要依赖当前的 state 去计算下一个 state，如果有这种累加需求的，可以使用 state 的函数参数： handleClick=()=>{ this.setState((prevState,props)=>{ return { counter: prevState.counter + 1 } }) } hook 下的写法： setCounter(count=>{ return count + 1 }) state 可以接受函数参数，函数的第一个参数 prevState 是上一次执行 setState 方法后的结果，第二个参数 props 是当前最新的 props。 实际的使用场景：一个列表需要全选功能，现已经有选中单项的方法，在全选时循环调用单项的选中方法，然后往 state 中的 active 数组 push 被选中的项的id，如果没有按照上述的方式进行改造，获取的 active 一直都是原始的值，结果就是只有最后一次是生效的。 举个迷惑性的例子： state = { count: 0 } componentDidMount(){ this.setState({ count: this.state.count + 1 }, () => { console.log(this.state.count) }) this.setState({ count: this.state.count + 1 }, () => { console.log(this.state.count) }) } 最后打印的结果是1,1，因为 React 会将修改同一个属性的操作进行合并，只有最后一个操作会被执行。 state = { count: 0 } componentDidMount(){ this.setState( preState=> ({ count:preState.count + 1 }),()=>{ console.log(this.state.count) }) this.setState( preState=>({ count:preState.count + 1 }),()=>{ console.log(this.state.count) }) } 如果使用函数则操作不会被合并，每一个操作都会被执行，所以这里最后 count 的值是 2，由于回调时最后执行，所以这里打印的结果是2,2","link":"/post/55008/"},{"title":"ES6 - Promise","text":"Promise API &amp; 手写 Promise 概念本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了，举个例子： function B(){}; function C(){}; function A(args,B,C){}; // 函数A接受参数和两个回调函数 转换成 Promise 形式： A(args).then(B,C) 链式调用概念连续执行两个或者多个异步操作是一个常见的需求，在上一个操作执行成功之后，开始下一个的操作，并带着上一步操作所返回的结果。我们可以通过创造一个 Promise 链来实现这种需求。 每个 Promise 对象都可以在其上多次调用 then 方法，then 方法会返回一个全新的 Promise 对象，下一个 then 方法其实是依附于返回的 Promise 对象，这样层层挂钩就形成了 promise 链： new Promise((resolve,reject) => { resolve('start') }).then(data => { console.log(data); // 'start', then 的参数是上一个 Promise 对象的 resolve 的参数 return Promise.resolve(1); }).then(data => { console.log(data); // 1 }) 中断调用如果要中途跳出链式调用，就需要用reject()抛出异常，用catch()去接受异常，为了和其他报错区别开来，可以定义一个 manualExit 的变量作为 reject 的参数： new Promise((resolve,reject) => { resolve('start') }).then(data => { return Promise.resolve(1); }).then(data => { reject({ manualExit : true }) }).catch(err => { if(err.manualExit){ // 手动退出 }else{ // 其他异常 } }).then(data => { // 依然会执行 }) 当 reject 执行时，会跳过后面的 then 方法，直接执行 catch，这里需要注意的是，catch 方法最好放在最后，因为 catch 方法会返回一个新的 resolved 的 Promise 实例，所以在 catch 之后的 then 方法依旧会被执行。 属性.finallyES2018 引入标准，不论 Promise 对象最后是何种状态（fulfilled / rejected），都会执行该操作，如果代码需要在成功或者失败两种情况下都运行，写入.finally()中可以减少代码量。 promise .then(result => { console.log('X') }) .catch(error => { console.log('X') }) // 等同于 promise .finally(() => { console.log('X') }); .allconst p = Promise.all([p1, p2, p3]); .all()相当于&amp;&amp;操作符，它接受由多个 Promise 实例组成的数组，当所有实例的状态都变为 fulfilled 时，p 的状态才会变成 fulfilled，只要其中一个实例被 rejected，那么状态就会变成 rejected。 const p1 = new Promise((resolve, reject) => { resolve('resolved'); }) .then(result => result) const p2 = new Promise((resolve, reject) => { throw new Error('rejected'); }) .then(result => result) Promise.all([p1, p2]) .then(result => console.log(result)) .catch(e => console.log(e)); // 由于p2报错，所以会进入catch 如果 p2 设置了 catch，并且返回了错误，那结果就不一样了。catch 方法会返回一个新的 resolved 的 Promise 实例，p2 实际上是指向了这个实例，导致 .all() 方法中两个实例都是 resolved，因此会进入.then()而非.catch()。 ... const p2 = new Promise((resolve, reject) => { throw new Error('rejected'); // or reject('rejected') }) .then(result => result) .catch(e => e); Promise.all([p1, p2]) .then(result => console.log(result)) // 实际进入的是then .catch(e => console.log(e)); .any.any()相当于||操作符，它接受由多个 Promise 实例组成的数组，只要有一个实例的状态变为 fulfilled 时，p 的状态就会变成 fulfilled，当所有实例的状态都变为 rejected 时 p 的状态才会变成 rejected。 const resolved = Promise.resolve(2); const rejected = Promise.reject(-1); const anyPromise = Promise.any([resolved, rejected]); anyPromise.then(function (results) { console.log(results); // 2 }); .raceconst p = Promise.race([p1, p2, p3]); .race()接受由多个 Promise 实例组成的数组，当其中一个实例的状态发生改变时，p 的状态就会改变并将率先改变的实例的返回值（不论成功/失败）传递给回调函数。 race 的特性可以用于监听 fetch 请求是否超时： function _fetch(fetch_promise,timeout){ return Promise.race([ fetch_promise, new Promise((resolve, reject)=>{ setTimeout(()=>{ reject(new Error('timeout')); },timeout) }) ]).then(()=>{ console.log('success') }).catch(()=>{ console.log('error'); }) } .allSettledES2020 引入标准，.allSettled()接受由多个 Promise 实例组成的数组，返回一个新的 Promise，只有所有的实例都返回结果时（不论 fulfilled 还是 rejected）才会返回每个 Promise 的状态（由 {status,reason/value}组成的数组），要注意的时.allSettled()不会失败。 const resolved = Promise.resolve(42); const rejected = Promise.reject(-1); const allSettledPromise = Promise.allSettled([resolved, rejected]); allSettledPromise.then(function (results) { console.log(results); }); // [{status: 'fulfilled', value: 42}, {status: 'rejected', reason: -1}] .resolve.resolve()可以将现有对象转换成 promise 对象，有以下几种情况： 对象是 Promise 实例：直接返回； 对象是由 then 方法的实例：转换成 Promise 对象，然后立即执行 then 内的方法； let thenable = { then: function(resolve, reject) { resolve(42); } }; let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value); // 42 }); 对象不具备 then 方法或者压根不是对象（甚至没有）：返回一个新的 Promise 对象，状态为 resolved： const p = Promise.resolve('Hello'); p.then(function (s){ console.log(s) }); // Hello const p = Promise.resolve(); p.then(function () { // ... }); .reject.reject(reason)返回一个新的 Promise 实例，该实例的状态为 rejected，传入的 reason 会原封不动的返回。 const p = Promise.reject('rejected'); // 等同于 const p = new Promise((resolve, reject) => reject('rejected')) p.then(null, function (s) { console.log(s) // rejected }); 手写 Promisefunction myPromise(constructor){ let self=this; self.status=\"pending\"; // 定义状态改变前的初始状态 self.value=undefined; // 定义状态为resolved的时候的状态 self.reason=undefined; // 定义状态为rejected的时候的状态 self.then=function(onFullfilled, onRejected){ let self=this; switch(self.status){ case \"resolved\": onFullfilled(self.value); break; case \"rejected\": onRejected(self.reason); break; default: } } function resolve(value){ if(self.status===\"pending\"){ self.value=value; self.status=\"resolved\"; } } function reject(reason){ if(self.status===\"pending\"){ self.reason=reason; self.status=\"rejected\"; } } //捕获构造异常 try{ constructor(resolve,reject); }catch(e){ reject(e); } } async/awaitasync/await 是用来优化 Promise 的回调问题，被称作是异步的终极解决方案。 async：Promise 的语法糖，返回一个 Promise，如果在函数中 return 一个常量，async 会把这个常量通过 Promise.resolve() 封装成 Promise 对象，如果返回的是 Promise 对象，则以返回的 Promise 为准。 返回常量： async function hello() { return \"Hello\" }; hello(); // Promise {&lt;fulfilled>: \"Hello\"} 返回 Promise： async function hello() { return Promise.reject(\"Hello\") }; hello(); // Promise {&lt;rejected>: \"Hello\"} await:await 可以放在任何的异步前面，会阻塞代码运行直到其右侧 Promise 完成，然后返回结果值。 async function hello() { return greeting = await Promise.resolve(\"Hello\"); }; hello().then(val=>console.log(val)); // Hello","link":"/post/28a4ac99/"},{"title":"ES6 - Map &amp; Set","text":"Map 和 Set 的 API 及应用场景 Map概念Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。 和对象相比较Map 和 Object 的区别主要有两个： Map 中的键和值可以使任意类型的，而 Object 中键名只能是字符串或者Symbol。 Map 的键值是有序的且有内置的迭代方法，而 Object 是无序的需要通过for...in或者Object.keys()来实现迭代。 Map 能够通过 size 属性获取到键的个数，而 Object 只能手动去计算。 应用场景 需要大量增删操作： Map 增删修改的效率更高，Object 没有内置的删除方法，需要使用delete obj.id的方法来删除键，效率不高。 需要进行迭代操作： Map 因为自带迭代方法forEach()，且支持for...of方法遍历，操作起来更方便。 数据的键名为未知类型： 因为 Map 的键名可以为任意类型，而 Object 的键名只能是字符串或者 Symbol。 属性.size：返回键值对的数量。 方法.clear()：清除所有键值对。 .delete(key)：清除单个元素，并返回一个布尔值来表示是否移除成功。 .entries()：返回一个Iterator对象，它按插入顺序包含了 Map 对象中每一个元素[key,value]数组。 .keys()：返回一个Iterator对象，它按插入顺序包含了 Map 对象中每一个元素的 key。 .values()：返回一个Iterator对象，它按插入顺序包含了 Map 对象中每一个元素的 value。 .get(key)：获取键对应的值，不存在则返回 undefined。 .set(key,value)：设置键的值，返回该 Map 对象。 .has(key)：判断是否存在该键。 .forEach()：迭代方法。 例子const map1 = new Map(); map1.set('a', 1); map1.set('b', 2); map1.set('c', 3); console.log(map1.get('a')); // 1 map1.set('a', 97); console.log(map1.get('a')); // 97 console.log(map1.size); // 3 map1.delete('b'); console.log(map1.size); // 2 Set概念Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。 属性.size：返回 Set 对象中值的个数。 方法.clear()：清除 Set 对象内的所有值。 .delete( value )：清除单个值，并返回一个布尔值来表示是否移除成功。 .add( value )：在 Set 对象尾部添加一个值。返回该 Set 对象。 .entries()：返回一个Iterator对象，它按插入顺序包含了 Set 对象中每一个值[value,value]数组。 .keys()：返回一个Iterator对象，它按插入顺序包含了 Set 对象中每一个值。 .values()：与 keys 方法保持一致。 .has( value )：判断是否存在该值。 .forEach()：迭代方法。 例子let mySet = new Set(); mySet.add(1); // Set [ 1 ] mySet.add(5); // Set [ 1, 5 ] mySet.add(5); // Set [ 1, 5 ] mySet.add(\"some text\"); // Set [ 1, 5, \"some text\" ] let o = {a: 1, b: 2}; mySet.add(o); mySet.entries(); // {1 => 1, 5 => 5, 'some text' => 'some text', {…} => {…}} mySet.add({a: 1, b: 2}); // o 指向的是不同的对象，所以没问题 mySet.has(1); // true mySet.has(3); // false mySet.has(5); // true mySet.has(Math.sqrt(25)); // true mySet.has(\"Some Text\".toLowerCase()); // true mySet.has(o); // true mySet.size; // 5 mySet.delete(5); // true，从 set 中移除 5 mySet.has(5); // false, 5 已经被移除 mySet.size; // 4，刚刚移除一个值 console.log(mySet); // logs Set(4) { 1, \"some text\", {…}, {…} }","link":"/post/a878425f/"},{"title":"JS原理 - 一些函数概念","text":"匿名函数、自执行函数、高阶函数，柯里化 匿名函数没有函数名的函数被称作匿名函数，形式为：function(){}，匿名函数能让闭包更加简洁。 使用具名函数进行闭包： function foo(){ let a = 0; function child(){ a+=1; console.log(a); } return child } const x = foo(); x(); // 1 x(); // 2 使用匿名函数进行闭包： function foo(){ let a = 0; return function(){ a+=1; console.log(a); } } const x = foo(); x(); // 1 x(); // 2 自执行函数自执行函数，顾名思义，是会自己执行的函数，不需要额外的调用，形式为：(function(){})()。 因为匿名函数拥有独立的词法作用域，避免外部访问自执行函数内的变量，所以在自执行函数内的变量不会污染全局作用域。 上面的匿名函数闭包可以使用自执行函数进行修改： const x = (function(){ let a = 0; return function(){ a+=1; console.log(a); } })(); x(); // 1 x(); // 2 再来看一个古老的面试题： for (var i = 0; i &lt; 5; i++) { setTimeout(function(){ console.log(i); }, 1000); } 因为宏任务、微任务的工作原理，会先执行完 for 循环之后再去执行定时器，所以上面的代码会打印出 5 5 5 5 5。 那么如果要让他打印出 0 1 2 3 4 需要怎么样修改代码？ 首先 JS 中调用函数传递参数是按值传递的，传入的参数会被复制一份，然后再创建函数执行上下文，所以拿到的都是当时的值，同时产生一个闭包，将值保存下来。 for (var i = 0; i &lt; 5; i++) { function foo(a) { setTimeout(function(){ // 这个函数后面还会被调用，相当于是被return出去 console.log(a); }, 1000); }; foo(i) } // 使用立即执行函数去优化一下代码 for (var i = 0; i &lt; 5; i++) { (function (a) { setTimeout(function(){ console.log(a); }, 1000); })(i); } // 这样也是可以的 for (var i = 0; i &lt; 5; i++) { setTimeout((function(a){ return function(){ console.log(a); } })(i), 1000); } 再来看一个例子： function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push(function () { return i * i; }); } return arr; } var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; f1(); // 16 f2(); // 16 f3(); // 16 这个理解很简单，往数组里 push 的是一个未执行的函数，所以最后执行出的结果都是 4 * 4 = 16，那如果想要让打印出来的结果分别是：1、4、9 ，需要如何修改函数？ 第一种：将 push 方法包裹在自执行函数内， function count() { var arr = []; for (var i=1; i&lt;=3; i++) { (function(a){ // 按值传递 arr.push(function () { // 放入数组后再调用，相当于return了函数出去 return a * a; }); })(i) } return arr; } var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; f1(); // 1 f2(); // 4 f3(); // 9 第二种：将 push 的回调函数用自执行函数进行嵌套，然后返回一个匿名函数，非常标准的闭包 function count() { var arr = []; for (var i=1; i&lt;=3; i++) { arr.push((function (n) { return function () { return n * n; } })(i)); } return arr; } var results = count(); var f1 = results[0]; var f2 = results[1]; var f3 = results[2]; f1(); // 1 f2(); // 4 f3(); // 9 高阶函数满足下列条件之一的，可以被称作高阶函数： 函数可以作为参数传递 var arr = [1, 55, 23, 6]; arr.sort(function(a, b){ return a - b; }) 函数可以作为返回值输出 function foo(){ let a = 0; function child(){ a+=1; console.log(a); } return child } 函数柯里化柯里化是一种函数的转换，他是将一个函数从可调用的f(a,b,c)转换为可调用的f(a)(b)(c)，柯里化不会调用函数，只是对函数进行转换。 举个例子：现在有一个 add 函数 function add(a, b){ return a + b; } 现在要对他实行柯里化，创建一个 curry 函数，将函数作为他的传入参数，然后返回一个函数： function curry(f) { return function(a) { return function(b) { return f(a, b); }; }; } const curryAdd = curry(add); curryAdd(1)(2); // 3 可以看到，这里还是有闭包的思想存在，在调用curryAdd(1)的时候，会保留他的词法作用域，返回一个 function(b)。 那么看起来让函数更加复杂的柯里化有什么意义呢？ 举个例子：如果一类需求的 x 都是1，如果不使用柯里化，那么每一次调用，都是add(1,n)的形式，如果用柯里化的形式add(1)(n)，add(1)的结果可以存储下来，减少重复运算。 var add = function(x) { return function(y) { return x + y; }; }; var increment = add(1); increment(2); // 3 callee &amp; callercallee在函数的内部，有两个特殊的对象：arguments 和 this。其中 arguments 是一个类似数组的对象，包含着传入函数的所有参数。 虽然 arguments 的主要用途是保存函数参数，但这个对象有一个属性 callee，该属性是一个指针，指向拥有这个 arguments 对象的函数。 例如下面的例子中，在函数内调用了自身，如果外层函数修改了名称，而其函数内部的名称没有做修改，那么就会出现错误，使用 callee 就能解决这个问题。 function factorial(num){ if(num &lt;= 1){ return 1; }else{ return num * factorial(num-1); } } // 修改为 function factorial(num){ if(num &lt;= 1){ return 1; }else{ return num * arguments.callee(num-1); } } callercaller是函数对象的一个属性，该属性保存着调用当前函数的函数的引用（指向当前函数的直接父函数）。 function a(){ b(); }; function b(){ console.info(b.caller); }; a(); // ƒ a(){ b() } callee 和 caller 也可以结合起来使用，例如下述代码能实现和上面代码一样的功能，且脱离了对函数名称的依赖。 function a(){ b(); }; function b(){ console.info(arguments.callee.caller); }; a(); // ƒ a(){ b() }","link":"/post/22071/"},{"title":"JS原理 - 变量提升","text":"变量提升（Hoisting），是指在JavaScript代码执行过程中，JS 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。 要理解变量提升的概念，首先要知道 JS 引擎运行代码时，会对代码进行块级解析然后执行，而非未经解析就逐行执行。在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；在代码执行阶段，JS 引擎会从变量环境中去查找自定义的变量和函数。 然后分清什么是声明？什么是赋值？ var a = \"hello\"; // 等同于 var a; // 声明部分 a = \"hello\"; // 赋值部分 function foo(){}; // 完整的函数声明，没有涉及到赋值操作 var foo = function(){}; // 等同于 var foo; // 声明部分 foo = function(){}; // 赋值部分 其中var a和function foo(){}这两个声明部分会被提升，而a = &quot;hello&quot;和foo = function(){}这两个赋值部分不会被提升。 那么下面代码的输出就很好理解了： console.log(name); // undefined say(); // \"A\" foo(); // throw Error: foo is not a function, 此时 foo 是 undefined 不能被执行 var name = \"Mike\"; function say(){ console.log(\"A\") }; var foo = function(){ console.log(\"B\") }; 那如果出现函数和变量同名的情况呢？ 需要记住一个概念：变量提升（编译阶段）时，函数声明会覆盖变量声明，但不会覆盖变量的值，在执行阶段，后定义的会覆盖之前定义的。看个例子： console.log(foo); function foo() {}; var foo = 2; console.log(foo); // 等同于 var foo; fucntion foo(){}; // 变量提升 console.log(foo); // f foo() {} foo = 2; console.log(foo); // 2 再来看个例子： foo(); var foo = function() { console.log('foo1'); } foo(); function foo() { console.log('foo2'); } foo(); // 等同于 var foo = undefined; function foo() { console.log('foo2'); } foo(); // foo2 foo = function() { console.log('foo1'); } foo(); // foo1 foo(); // foo1 需要注意的是，变量提升并不是提到所有代码的顶部，如果变量在函数内部，则会被提升到当前函数的顶部。 看个例子： var foo = 1; function bar() { if (!foo) { var foo = 10 }; console.log(foo); } bar(); // 等同于 var foo; foo = 1; function bar(){ var foo; // foo is undefined if(!foo) { foo = 10 }; console.log(foo); } bar(); // 10","link":"/post/36519/"},{"title":"JS原理 - 构造函数、原型与继承详解","text":"构造函数、原型的基础知识和继承的实现方式 原型每一个对象（null 除外）都有其原型对象，对象以原型对象为模板，从原型继承方法和属性。 原型链原型对象也可能拥有原型，并从中继承方法和属性，一层一层以此类推，这种关系就被称为原型链（下图蓝色线条）。 当查找某个属性或者方法时，会通过__proto__属性，一级一级向上查找，直到原型链上的所有__proto__都被查找完了，才返回undefined。 小贴士：因为__proto__不是规范中规定的，是浏览器实现的，所以尽可能不通过__proto__去获取原型，可以通过Object.getPrototypeOf()去获取， 属性__proto__、 constructor属性是对象所独有的，而prototype属性是函数独有的，函数作为一种特殊的对象，所以也会拥有__proto__、 constructor属性。 这里需要注意一点的是，修改原型属性并不会影响构造函数的属性，实例会通过__proto__逐级向上查找原型，而构造函数的__proto__依次指向Function.prototype、Object.prototype、null，没有经过构造函数的原型。举个例子： function foo(){}; foo.prototype.friend = 'Nick'; console.log(foo); // ƒ foo(){} console.log(foo.friend); // undefined console.log(foo.prototype.friend); // Nick 原型属性每个函数都有原型属性（prototype），下面以函数 foo 来举例： function foo(){}; console.log(foo.prototype); // output { constructor: ƒ foo(), // 指向构造函数 __proto__: { // Function的原型对象 constructor: ƒ Object(), // Function的构造函数 hasOwnProperty: ƒ hasOwnProperty(), // A.hasOwnProperty(B) 判断A是否含有自有属性B isPrototypeOf: ƒ isPrototypeOf(), // A.isPrototypeOf(B) 判断A是否存在于B的原型链上 propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() } } 当添加属性到函数的原型上时： function foo(){}; foo.prototype.friend = 'Nike'; console.log(foo.prototype); // output { friend: 'Nike', constructor: ƒ foo(), __proto__: { constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() } } 自有属性在函数内部定义的属性叫做自有属性： function f() { this.a = 1; this.b = 2; // 这里的 a 和 b 就是自有属性 } 自有属性和原型属性有什么区别？ 在构建函数中，自有属性优先级会高于原型的属性，即存在相同名称时，自有属性会覆盖原型属性； 在实例中修改引用类型的自有属性 A 时不会导致其他实例的属性 A 发生变动，因为这些属性 this 指向了 new 运算符创建出的不同的对象； 但是引用类型的原型属性 B 在修改时，继承于同一父类的实例内的属性 B 都会发生更改； 所以一般都在构造函数内定义属性，在 prototype 内定义方法。 构造函数构造函数就是 new 关键字创建实例时调用的函数，是生成实例的模板，下述例子中 foo 就是构造函数： function foo(friendName){ // 自有属性 this.friend = friendName; } // 原型属性 foo.prototype.color = \"red\"; foo.prototype.eat = function(){ console.log('eatting') } new 运算符做了什么？ 构造函数会经历以下 4 个步骤： 创建一个对象：let newObj = {}； 将构造函数的原型赋值给新对象：Object.setPrototypeOf( newObject , foo.prototype)； 更改构造函数 this 指向新对象，然后执行构造函数的代码：foo.call( newObj )； 返回新对象； 注意点 new 运算符会继承构造函数的自有属性和原型属性，但是不会继承静态属性，举个例子： function foo(friendName){ // 自有属性 this.friend = friendName; } foo.extra = 'hello'; foo.prototype.sex = 'female'; const Foo = new foo(\"Nick\"); console.log(Foo.friend); // output: Nick console.log(Foo.extra); // output: undefined console.log(Foo.sex); // output: female 继承原型链继承原型链继承的方法就是重写原型，将子构造函数的 prototype 指向父构造函数的实例： function Parent () { this.friend = 'Nick'; this.getFriend = function () { console.log(this.friend); } } function Child () {} Child.prototype = new Parent(); // 重写原型，会影响后续创建的实例 const child1 = new Child(); console.log(child1.friend); // 'Nick' 这里将 prototype 指向new Parent()创建出的实例，而非 Parent.prototype ，是为了继承 Parent 的自有属性 friend 和 getFriend。 缺点： 父类的引用类型的自有属性会被所有实例共享 这是因为在修改 child1 的 friend 属性时，因为其构造函数 Child 内没有 friend 属性，所以 child1 也没有 friend 属性，于是沿着原型链（__proto__）往上寻找 friend 属性，__proto__ 指向的是 Parent 创造出的实例对象，并在这里找到了自有属性 friend，由于 friend 属于引用类型，所以一旦修改，指向该内存地址的所有涉及到的 friend 的值都会被修改。 function Parent () { this.friend = ['kevin']; this.getFriend = function () { console.log(this.friend); } } function Child () {} Child.prototype = new Parent(); const child1 = new Child(); child1.friend.push('mike'); console.log(child1.friend); // ['kevin','mike'] const child2 = new Child(); console.log(child2.friend); // ['kevin','mike'] 这里还有一个问题，引用类型会被所有实例共享，那么基础类型是否会被共享？ 答案是不能被共享，因为访问原型中的基本类型时，访问到的其实是他的映射副本，对于基本类型的值的修改只有在当前实例中生效，举个例子： function Parent () { this.friend = 'kevin'; this.getFriend = function () { console.log(this.friend); } } function Child () {} Child.prototype = new Parent(); const child1 = new Child(); child1.friend = 'molly'; console.log(child1.friend); // molly const child2 = new Child(); console.log(child2.friend); // kevin 创建实例的时候无法向父类型（Parent）传参 无法实现多继承 借用构造函数继承借用构造函数继承就是在子类的构造函数内部调用父类的构造函数，这样一来父类型构造函数的内容就赋值给了子类型的构造函数。 这种继承方式，避免了引用类型的自有属性被所有实例共享，且可以通过 Child 向 Parent 传参。 function Parent () { this.friend = ['kevin', 'mike']; // 要实现非全局共享，这里的引用类型对象需要是新创建的 } function Child () { Parent.call(this); } const child1 = new Child(); child1.friend.push('yayu'); console.log(child1.friend); // [\"kevin\", \"mike\", \"yayu\"] const child2 = new Child(); console.log(child2.friend); // [\"kevin\", \"mike\"] 缺点： 部分继承，只能继承父类的自有属性，不能继承父类原型的属性和方法 组合式继承将原型链继承和借用构造函数继承相结合，在子类里面调用父类的构造函数，继承其自有属性，避免自有属性的全局共享；然后通过改写原型对象，让子类和父类的原型对象保持一致，这样子类就能获取到原型链上的属性和方法。 function Parent (number) { this.friend = ['kevin', 'mike']; this.sayNumber = function(){ console.log(number) } } function Child (number) { Parent.call(this,number); // 先借用构造函数继承，复制父类型构造函数的内容 } Child.prototype = Parent.prototype; // 后重写原型 Child.prototype.constructor = Child; // 修复构造函数指向 const child1 = new Child(2); child1.friend.push('yayu'); console.log(child1.friend); // [\"kevin\", \"mike\", \"yayu\"] child1.sayNumber(); // 2 const child2 = new Child(3); console.log(child2.friend); // [\"kevin\", \"mike\"] 寄生式组合继承组合式继承直接修改了原型的指向Child.prototype = Parent.prototype;，此时如果在子类的原型上追加方法，会影响到父类的原型。而寄生式组合继承需要用到Object.create()，作用是：创建一个新对象，使用现有的对象来提供新创建的对象的 __proto__，也就是原型对象，需要注意的是，这是浅拷贝。 function Parent (number) { this.friend = ['kevin', 'mike']; this.sayNumber = function(){ console.log(number) } } function Child (number) { Parent.call(this,number); } Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child; Child.prototype.test = '123'; console.log( Parent.prototype ); // 找不到test Class 继承ES6 加入的 class 属性提供了简单的继承方式：extends class Animal { constructor(name) { super(); this.name = name; } speak() { console.log(`${this.name} makes a noise.`); } } class Dog extends Animal { constructor(name) { super(name); // 调用父类的构造函数 } speak() { console.log(`${this.name} barks.`); } oldSpeak() { super.speak(); // 调用父类的方法 } } let d = new Dog('Mitzie') d.speak() // Mitzie barks. d.oldSpeak() // Mitzie makes a noise. ES5 和 ES6 继承方式的区别在于：ES5 是先创造子类的实例对象，然后再将父类的方法和属性添加到这个实例对象上；ES6 则是先创建父类的实例对象（在 constructor 内需要先调用 super()），然后再使用子类的构造函数修改实例对象。","link":"/post/de0024ee/"},{"title":"JS原理 - 理解事件捕获、冒泡与委托","text":"事件捕获和事件冒泡都是为解决 Js 事件处理顺序的问题而提出来的概念，是 DOM 事件流中的两个阶段，浏览器会遵循先捕获后冒泡的规则依次进入事件捕获阶段、到达目标阶段、事件冒泡阶段，可以在这三个阶段中对 Js 事件作出响应。 区别事件捕获：事件会由最外层（document 对象）接收，然后逐级下传至最具体的元素，常用于截获事件。 事件冒泡：事件会从最具体的元素接收，逐级上传至最外层，常用于对事件作出响应。 举个例子： &lt;div id=\"outer\"> &lt;p id=\"inner\">Click me!&lt;/p> &lt;/div> 如果给 inner 和 outer 都设置 click 监听，点击 inner 元素，事件捕获阶段， click 事件的接收顺序是： document &gt; html &gt; body &gt; div &gt; p，事件冒泡阶段，click 事件的接收顺序是：p &gt; div &gt; body &gt; html &gt; document 实例[查看初始例子] js部分： const a = document.getElementById(\"a\"), b = document.getElementById(\"b\"), c = document.getElementById(\"c\"); a.addEventListener( \"click\", function () { console.log(\"a1\"); }, true ); a.addEventListener(\"click\", function () { console.log(\"a2\"); }); b.addEventListener( \"click\", function () { console.log(\"b1\"); }, true ); b.addEventListener(\"click\", function () { console.log(\"b2\"); }); c.addEventListener(\"click\", function () { console.log(\"c1\"); }); c.addEventListener( \"click\", function () { console.log(\"c2\"); }, true ); 当点击元素 a 时输出：a1、a2 当点击元素 c 时输出：a1、b1、c1、c2、b2、a2 这里 c1 处于冒泡阶段，c2 处于捕获阶段，却是先触发 c1 后触发 c2，这是因为当点击元素 c 时，currentTarget（绑定监听事件的元素） 和 target（触发监听事件的元素） 是一致的，此时就处于目标阶段，而非捕获阶段或者冒泡阶段，此时事件都会按照注册的顺序依次触发。 stopPropagationstopPropagation 用于阻止捕获和冒泡阶段中当前事件的进一步传播 他还有一个孪生兄弟 stopImmediatePropagation，他们的区别在于后者会阻止监听同一事件的其他事件监听器被调用，举个例子： 如果使用stopPropagation，那么点击 a 元素的时候会打印出 a1、ax、a2 a.addEventListener(\"click\", function () { console.log(\"a1\"); }, true); a.addEventListener(\"click\", function (ev) { ev.stopPropagation(); console.log(\"ax\"); }, true); a.addEventListener(\"click\", function () { console.log(\"a2\") }, true); 如果使用的是stopImmediatePropagation，那么打印出来的结果是 a1、ax，没有 a2 了，因为被阻止监听了。 事件委托原理事件委托就是在父级元素上设置监听，当父元素监听到事件时，在冒泡阶段判断目标元素（target）与委托的元素是否一致，如果一致则触发方法，举个例子： &lt;ul id=\"list\"> &lt;li>item 1&lt;/li> &lt;li class=\"item\">item 2&lt;/li> &lt;li>item 3&lt;/li> ...... &lt;li>item n&lt;/li> &lt;/ul> &lt;script> document.querySelector('#list').addEventListener('click',ev => { if( ev.target.matches('li.item') ){ console.log('li click') }; }) &lt;/script> 上述代码在 ul 上委托了点击事件，当点击 ul 里面的任意元素时，便会监听到 click 事件，然后使用.matches()方法判断目标元素和委托元素是否一致，如果一致则执行方法。 优缺点使用事件委托的好处在于： 避免了多次类似的事件绑定与解绑，减少内存消耗。 支持动态绑定，与 AJAX 配合更好。 不过事件委托也有它的局限性： 事件委托基于事件冒泡，focus、blur等事件不支持委托。 如果有一层元素设置了 event.stopPropagation()阻止了事件冒泡，那么委托就会失败。 封装为了更好的复用事件委托，可以将它封装成公共方法： function eventDelegate(parentSelector, targetSelector, event, foo){ document.querySelector(parentSelector).addEventListener(event, ev => { if( ev.target.matches(targetSelector) ){ foo.call(ev.target); } }); }; eventDelegate('#list','li.item','click',function(){ console.log(this) // => &lt;li class=\"item\">item 2&lt;/li> });","link":"/post/d73eb7a7/"},{"title":"JS原理 - 理解作用域","text":"作用域作用域（scope）是一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。简单来说，作用域规定了如何查找变量。 JavaScript 采用了静态作用域，函数的作用域在函数被定义时就被确定的。无论函数在哪里被调用，无论如何被调用，它的作用域只由函数定义所处的位置决定。 看一个例子： var value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); } bar(); // 1 当执行 foo 函数时，先从 foo 函数内部查找是否有变量 value，结果没有，于是就沿定义函数的位置，查找上一层的代码，查找到全局变量 value ，所以函数执行的结果为 1。 再看一个例子： var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f(); } checkscope(); // local scope 对此，权威指南的解释是这样的：JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 最后看一个例子： var bar = { myName:\"time.geekbang.com\", printName: function () { console.log(myName) } } function foo() { let myName = \"A\" return bar.printName } let myName = \"B\" let _printName = foo() _printName(); // B bar.printName(); // B 最后打印出来的是两个 B，这里是为了说明在寻找变量的时候是在当前作用域中寻找，而不是在代码结构内向上寻找，在一开始的时候，我经常犯这样的错误。 块级作用域在ES6之前，ES的作用域只有两种：全局作用域和函数作用域。 全局作用域中的对象在代码中的任何地方都能访问，只要页面没有被销毁，便一直存在。 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。 那为什么要加入块级作用域呢？主要由于 JS 的变量提升存在着变量覆盖、变量污染等设计缺陷，所以 ES6 引入了块级作用域关键字来解决这些问题。 举个变量覆盖的例子： var myname = \"A\" function showName(){ console.log(myname); if(0){ var myname = \"B\" } console.log(myname); } showName() 最后打印的结果是两个undefined，因为函数showName内存在变量提升，但是没有进行赋值操作。 再看个变量污染的例子： function foo(){ for (var i = 0; i &lt; 7; i++) { } console.log(i); } foo() 同样是因为变量提升，在循环之后，i 并没有被销毁，所以打印出来的结果是 7。 那么 JS 是如何既支持变量提升又支持块级作用域的？ 这就要从执行上下文入手了，看一个具体的例子： function foo(){ var a = 1 let b = 2 { let b = 3 var c = 4 let d = 5 console.log(a) console.log(b) } console.log(b) console.log(c) console.log(d) } foo() 首先，JS 引擎会对函数代码进行编译，生成如下图所示的执行上下文 从图上可以看出 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。 接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，与此同时作用域块中使用 let 声明的 b 并没有去影响词法环境中已有的 b 的值，而是将他们放在了相互独立的单独区域 当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给JavaScript引擎，如果没有查找到，那么继续在变量环境中查找 作用域链在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。 当一段代码使用了一个变量时，JS 引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么 JS 引擎会继续在 outer 所指向的执行上下文中查找，一直找到全局上下文。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。 看个例子： function bar() { console.log(myName) } function foo() { var myName = \"极客邦\" bar() } var myName = \"极客时间\" foo() 例子中的执行上下文如下图：","link":"/post/7851/"},{"title":"JS原理 -事件循环 Event Loop","text":"JS 中的事件循环及相关实例 定义JS 在设计之初是被用来验证表单和操控DOM元素，如果js是多线程的，且两个线程同时对一个DOM元素进行了相互冲突的操作，那么浏览器的解析器是无法执行的，所以 JS 被设计为单线程。 Event Loop 即事件循环，是浏览器、Nodejs 避免因单线程运行出现阻塞的一种机制，也就是说通常说的异步。 宏队列和微队列宏队列（macro task queue）以下异步任务的回调会依次进入宏队列，等待后续被调用： setTimeout setInterval I/O（文件读写） requestAnimationFrame (浏览器独有) UI rendering (浏览器独有) 微队列（micro task queue）以下异步任务的回调会依次进入微队列，等待后续被调用： Promise MutationObserver process.nextTick (Node独有) Object.observe(ES7废弃) 简要流程事件循环简要的流程如下： 执行全局 script 代码，如果遇到宏任务，追加到宏队列中，如果遇到微任务，追加至微队列中。 全局代码执行完毕，调用栈清空。 检查微队列是否为空，如果不为空，依次取出微队列内的回调任务放入调用栈中，直到执行完成所有微任务，此时微队列为空，调用栈为空。 取出宏队列队首的任务，放入调用栈，执行完毕后，重复步骤 3 的操作，Event Loop 就形成了。 流程的重点就在于：每一次调用宏队列里的任务后，都需要去检查微队列是否为空，如果有微任务则执行微任务。 例子console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); 事件循环详细过程： 执行全局 script 代码，分配任务到队列。 宏队列：setTimeout callback 微队列：Promise then Log：script start、script end 此时微队列不为空，需要处理微队列。 宏队列：setTimeout callback 微队列： Log：script start、script end、promise1、promise2 微队列处理完成之后，此时微队列已空，然后再处理宏队列里的 setTimeout callback 任务。 宏队列： 微队列： Log：script start、script end、promise1、promise2、setTimeout 复杂的例子console.log(1); setTimeout(() => { console.log(2); Promise.resolve().then(() => { console.log(3) }); }); new Promise((resolve, reject) => { console.log(4) resolve(5) }).then((data) => { console.log(data); }) setTimeout(() => { console.log(6); },1000) setTimeout(() => { console.log(7); },100) console.log(8); 事件循环详细过程： 执行全局 script 代码，因为 Promise 构造函数执行时立即调用，所以console.log(4)是同步的。 宏队列：setTimeout callback、setTimeout callback、setTimeout callback 微队列：Promise then Log：1、4、8 此时微队列不为空，需要处理微队列。 宏队列：setTimeout callback、setTimeout callback、setTimeout callback 微队列： Log：1、4、8、5 处理 setTimeout callback，又因为 setTimeout 内包含了一个 Promise 函数，所以执行了 setTimeout 的 callback 时，微队列又添加了一个 Promise 的 callback。 宏队列：setTimeout callback、setTimeout callback、setTimeout callback 微队列：Promise then Log：1、4、8、5、2 完成宏队列里的一个任务后，判断微队列不为空，暂停处理宏队列，再次优先处理微队列。 宏队列：setTimeout callback、setTimeout callback、setTimeout callback 微队列： Log：1、4、8、5、2、3 依次处理剩下的宏队列任务。 Log：1、4、8、5、2、3、7、6 async 乱入async 的特性： async 定义的是一个 Promise 函数，和普通函数一样只要不调用就不会进入事件队列。 async function async1(){ console.log(1) await 1 console.log(2) } // 等价于 function async1() { console.log(1) return new Promise(resolve => { resolve(1) }).then(() => { console.log(2) }) } // 小试一下 async function async1 () { await new Promise((resolve, reject) => { resolve() }) console.log('A') } async1() new Promise((resolve) => { console.log('B') resolve() }).then(() => { console.log('C') }).then(() => { console.log('D') }) // 打印结果：B、A、C、D async 内部如果没有主动 return Promise，那么 async 会把函数的返回值用 Promise 包装。 根据返回是否有then属性，是否是Promise，Js引擎的处理方式也不一样： 非 thenable、非 promise（不等待） async function testA () { return 1; } testA().then(() => console.log(1)); Promise.resolve() .then(() => console.log(2)) .then(() => console.log(3)); // 输出结果：1/2/3 thenable（等待 1个then的时间） async function testB () { return { then (cb) { cb(); } }; } testB().then(() => console.log(1)); Promise.resolve() .then(() => console.log(2)) .then(() => console.log(3)); // 输出结果：2/1/3 Promise（等待 2个then的时间） async function testC () { return new Promise((resolve, reject) => { resolve() }) } testC().then(() => console.log(1)); Promise.resolve() .then(() => console.log(2)) .then(() => console.log(3)) .then(() => console.log(4)) // 输出结果：2/3/1/4 await 表达式会暂停整个 async 函数的执行进程并出让其控制权，只有当其等待的基于 promise 的异步操作被兑现或被拒绝之后才会恢复进程。即：遇到 await 关键字，await 右边的语句会被立即执行然后 await 下面的代码进入等待状态，等待 await 得到结果。 但是执行顺序和右侧函数的类型有关： 非 thenable、非 Promise（不等待） async function test () { console.log(1); await 1; console.log(2); } test(); console.log(3); Promise.resolve() .then(() => console.log(4)) .then(() => console.log(5)) .then(() => console.log(6)) .then(() => console.log(7)); // 输出结果: 1/3/2/4/5/6/7 thenable（等待 1个then的时间） async function test () { console.log(1); await { then (cb) { cb(); }, }; console.log(2); } test(); console.log(3); Promise.resolve() .then(() => console.log(4)) .then(() => console.log(5)) .then(() => console.log(6)) .then(() => console.log(7)); // 输出结果: 1/3/4/2/5/6/7 Promise（不等待） async function test () { console.log(1); await new Promise((resolve, reject) => { resolve() }) console.log(2); } test(); console.log(3); Promise.resolve() .then(() => console.log(4)) .then(() => console.log(5)) .then(() => console.log(6)) .then(() => console.log(7)); // 输出结果: 1/3/2/4/5/6/7 async function async1() { console.log('1') await new Promise((resolve) => { console.log('2') resolve() }).then(() => { console.log('3') }) console.log('4') } async1() // 输出结果： 1/2/3/4 来几个 async/await 的例子： async function async1() { console.log( '1' ); await async2(); console.log( '2' ); }; async function async2() { console.log( '3' ); }; console.log( '4' ); setTimeout( function () { console.log( '5' ); }, 0 ); async1(); new Promise( function ( resolve ) { console.log( '6' ); resolve(); } ).then( function () { console.log( '7' ); } ); console.log( '8' ); // 事件循环的详细顺序： 1. 执行同步代码 console.log。 Log：4 2. 将 setTimeout 添加至宏队列。 3. 执行 async1。 Log：4、1 4. 执行 async2，await 阻塞后续代码，先执行外部的代码，有因为 async 会返回一个 Promise，所以将返回的 Promise 添加至微队列。 Log：4、1、3 5. 执行 Promise，将新生成的 Promise 添加至微队列。 Log：4、1、3、6 6. 执行同步代码 console.log。 Log：4、1、3、6、8 7. 查看微队列，发现存在两个 Promise，按顺序执行 Log：4、1、3、6、8、2、7 8. 最后执行宏任务里的 setTimeout Log：4、1、3、6、8、2、7、5 setTimeout(function () { console.log('9') }, 0) console.log('1') async function async1() { console.log('2') await async2() console.log('8') } async function async2() { return new Promise(function (resolve) { console.log('3') resolve() }).then(function () { console.log('6') }) } async1() new Promise(function (resolve) { console.log('4') resolve() }).then(function () { console.log('7') }).then(function () { console.log('9') }) console.log('5') // 输出结果：1/2/3/4/5/6/7/8/9 // 重点：async2返回的是Promise，所以等待两个then（6/7） async function async1() { console.log('2') const data = await async2() console.log(data) console.log('9') } async function async2() { return new Promise(function (resolve) { console.log('3') resolve('8') }).then(function (data) { console.log('6') return data }) } console.log('1') setTimeout(function () { console.log('10') }, 0) async1() new Promise(function (resolve) { console.log('4') resolve() }).then(function () { console.log('7') }) console.log('5') // 输出结果：1/2/3/4/5/6/7/8/9/10","link":"/post/11477405/"},{"title":"JS基础 - JS中的距离","text":"在 JS 中可以获取到许多距离的值，但是很容易混淆，下面对能够获取到的值进行一个整理。 获取元素的位置信息调用APIgetComputedStyle()getComputedStyle() 获取的是元素 css 定义的属性，css 中是什么就返回什么，举个例子： #wrapper{ width:100px; height:100px; padding:10px; margin:4px; border:1px solid red; } document.querySelector('#wrapper').getComputedStyle().width getBoundingClientRect()getBoundingClientRect() 获取的是元素的位置信息：left、right、top、bottom 以及 width、height。 返回的 width = offsetWidth，height = offsetHeight。 offset*一句话：除了 margin 我都要。 offsetWidth / HeightoffsetWidth = cssWidth + padding + border; offsetHeight = cssHeight + padding + border; 注意：如果将元素的box-sizing设置为border-box，offsetWidth 就等于 cssWidth。 举个例子： #wrapper{ width:100px; height:100px; padding:10px; margin:4px; border:1px solid red; } &lt;div id=\"wrapper\">&lt;/div> 输出的结果： wrapper's offsetHeight：122px wrapper's offsetWidth：122px offsetLeft / TopoffsetLeft &amp; offsetTop = 相对祖先元素（position 不为 static 的元素）的偏移量，或者说两条边框之间的距离，不计算边框的宽度。 举个例子： wrapper 未设置 position #wrapper{ width:100px; height:100px; padding:10px; margin:4px; border:1px solid red; } #content{ width:50px; height:50px; padding:5px; margin:3px; border:1px solid red; } &lt;div id=\"wrapper\"> &lt;div id=\"content\">&lt;/div> &lt;/div> 输出的结果： wrapper's offsetLeft：4px wrapper's offsetTop：4px content's offsetLeft：18px（ 相对于 html 的偏移量 = 10px+4px+1px+3px ） content's offsetTop：18px 将wrapper 的 position 设置为 relative #wrapper{ width:100px; height:100px; padding:10px; margin:4px; border:1px solid red; position:relative; } 输出结果 content's offsetLeft：13px（ 相对于 warpper 元素的偏移量 = 10px+3px ） content's offsetTop：13px client*clientWidth / Heightoffset 减去 border 和滚动条的宽度就等于 client。 clientWidth = offsetWidth - border - scrollBar； clientHeight = offsetHeight - border - scrollBar； clientLeft / Top没有（左侧/顶部）滚动条时，clientLeft 与 clientTop 等于 border 的宽度； 有（左侧/顶部）滚动条时，等于 border 的宽度 + 滚动条的宽度。 特殊情况当我们在获取&lt;html&gt;元素（document. documentElement）尺寸的时候，client 给出的是 viewport （浏览器可视区域）的尺寸，而 offset 给出的是&lt;html&gt;元素的尺寸，例如：浏览器宽度是 1920px，当修改&lt;html&gt;元素的宽度为 10% 时，document. documentElement.clientWidth 为 1920，document. documentElement.offsetWidth 为 192。 获取滚动位置信息scrollWidth / Height通过 Element.scrollWidth/Height，可以获取到溢出的宽度/高度： scrollWidth = clientWidth + 溢出内容尺寸； scrollHeight = clientHeight + 溢出内容尺寸； scrollTop / Left因为浏览器间的兼容性差异，有三种API可以获取到 scrollTop/Left 的值，依次判断是否能够获取到值即可： let top = Element.scrollTop || window.pageYOffset || document.body.scrollTop; scrollTop：这个元素的顶部到视口可见内容的顶部的距离，当一个元素的内容没有产生垂直方向的滚动条，那么 scrollTop 为 0，scrollLeft 同理。 获取鼠标的位置信息mouseover / mouseenter 等鼠标事件都能够获取到一些位置信息，他们的参考坐标轴各不相同： clientX / Y以【浏览器的显示区域左上角的顶点】为坐标原点。 offsetX / Y以【元素自身左上角的顶点】为坐标原点。 layerX / Y以【有定位属性不为 static 的父元素的左上角的顶点】为坐标原点，如果自身的定位属性不为 static，则以自身的左上角顶点为坐标原点，且一直向上寻找到 body，如果依然没有符合的元素，则以 body 的左上角顶点为坐标原点。 pageX / Y以【当前文档的左上角的顶点】为坐标原点，也就是说如果页面的内容不发生变化，那么每次获取的位置是恒定的。 screenX / Y以【屏幕左上角的顶点】为坐标原点。","link":"/post/22b4340d/"},{"title":"JS原理 - 理解执行上下文与调用栈","text":"执行上下文JS 引擎运行代码时，会先对代码进行编译，经过编译后会生成两部分内容：执行上下文（Execution context）和可执行代码。 执行上下文是 JS 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如this、变量、对象以及函数等。 那么执行什么样的代码会创建执行上下文呢？一般来说有以下三种情况： 当执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。 当使用eval函数的时候，eval的代码也会被编译，并创建执行上下文。 那么创建出的执行上下文又该如何进行统一的管理呢？这时候就要用到调用栈了。 调用栈要弄清楚调用栈就要先弄明白函数调用和栈。 函数调用用下述的代码来解释下函数调用的过程 var a = 2; function add(){ var b = 10; return a+b; } add(); 在执行到函数add()之前，JS 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量。 从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。 执行上下文准备好之后，便开始执行全局代码，当执行到add这儿时，JavaScript判断这是一个函数调用，那么将执行以下操作： 从全局执行上下文中，取出 add 函数代码。 对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。 执行代码，输出结果。 完整流程如下图所示： 备注：上图中，编译代码过程var d=10应为var b=10，可执行代码除了return a+b还有b=10。 当执行到add函数的时候，我们就有了两个执行上下文了——全局执行上下文和add函数的执行上下文。 栈栈相当于一个死胡同，栈内的所有元素必须遵守先进后出的原则 什么是调用栈？调用栈亦称作执行栈，具有后进先出的结构，存储着代码执行期间创建的所有执行上下文。执行栈用于管理执行上下文，是 JS 引擎追踪函数执行的一个机制，通过执行栈可以追踪到哪个函数正在被执行以及各函数之间的调用关系。 栈的工作过程： 栈的底部最初会被压入全局执行上下文，所以只有当整个代码程序结束时，栈才会被清空； 当执行一个函数时，就会创建一个执行上下文，并压入执行上下文栈中，然后执行函数内的代码，当函数执行完毕时，其执行上下文会从栈顶弹出，并将函数返回值赋给调用函数的变量； 再次遇到函数时，重复步骤 2，直到全局代码执行完毕； 举个例子： console.log(\"global execution context\"); function foo() { console.log(\"foo is executing\"); console.log(\"foo has finished executing\"); } function bar() { console.log(\"bar is executing\"); foo(); console.log(\"bar has finished executing\"); } function baz() { console.log(\"baz is executing\"); bar(); console.log(\"baz has finished executing\"); } baz(); console.log(\"program successfully executed\"); // global execution context // baz is executing // bar is executing // foo is executing // foo has finished executing // bar has finished executing // baz has finished executing // program successfully executed 执行过程如下图所示： 如何利用调用栈？调用栈可以帮助我们快速追踪到哪个函数正在被执行以及各函数之间的调用关系，有两种方式可以查看调用栈信息。 使用开发者工具 打开“开发者工具”，点击 “Source” 标签，选择 JavaScript 代码的页面，然后在第3行加上断点，并刷新页面。你可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边 “call stack” 来查看当前的调用栈的情况，如下图： 使用控制台打印使用console.trace()来打印出当前函数的调用关系 栈溢出栈的容量是有限的，不能够无限的压入执行上下文，所以当出现如下述代码中的循环调用的时候，就容易出现栈溢出（Maximum call stack size exceeded）。 function division(a,b){ return division(a,b) } console.log(division(1,2))","link":"/post/52080/"},{"title":"JS原理 - 理解闭包","text":"闭包的概念以及相关知识点 概念闭包的本质就是：当前环境存在指向父级作用域的引用。 在函数内部声明一个新的函数（即内部函数），内部函数引用了其父函数的变量，并将内部函数作为值返回（return），在父函数被调用时就会形成闭包。 function foo(){ var name = 'lili'; // 父函数的局部变量 function child(){ console.log(name); // 引用父函数中声明的变量 }; return child; } const x = foo(); x(); // 此时形成闭包，确定对词法作用域的引用 是不是只有返回一个函数的形式的才是闭包呢？ 不，只需要存在指向父级作用域的引用的即可，举个例子： var fun3; function fun1() { var a = 2 fun3 = function() { a++; console.log(a); } } fun1(); fun3(); // 3 fun3(); // 4 作用访问内部变量闭包可以保持对词法作用域的引用，让外部函数能够访问内部函数的变量。 打个比方，有一根金条放在邻居家里，你不能入室去偷这根金条，但是你可以通过贿赂邻居家的小孩，让他帮你把金条从房子里拿出来，你就得到这根金条了。 function foo(increment){ let counter = 0; function child(){ counter += increment; console.log(counter); }; return child; } const _child = foo(1); _child(); // 1 _child(); // 2 _child(); // 3 console.log(counter); // error:counter is not defined 如果直接打印 counter 一定会得到counter is not defined，因为无法访问 foo 函数内部的变量，但通过闭包的形式，却可以打印出变量 counter 的值。 保留变量的引用而且 counter 能够实现累加，因为闭包保持了 foo 词法作用域中的变量（counter）和传入的参数（increment）的引用，除非手动销毁，不然词法作用域会一直保存在内存当中。 然后来看一个特殊情况，在返回的 child 函数中再套一个函数 inner，inner 打印出 child 函数里的变量 msg： function foo(increment){ let counter = 0; function child(){ counter += increment; console.log(counter); const msg = `counter is ${counter}`; return function inner(){ console.log(msg); } } return child; } const _child = foo(1); const _inner = _child(); // 1 _child(); // 2 _child(); // 3 _inner(); // counter is 1 从下图可以看到，出现了两个 Closure（闭包）： 如果要让 counter 获取到最新的值，有两种解决方式： 改变调用_child()的位置： function foo(increment){ let counter = 0; function child(){ counter += increment; console.log(counter); const msg = `counter is ${counter}`; return function inner(){ console.log(msg); } } return child; } const _child = foo(1); _child(); // 1 _child(); // 2 const _inner = _child(); // 3 _inner(); // counter is 3 这样虽然还是产生了闭包，但是闭包内的 counter 值是最新的。 将 msg 移入至 inner 函数内，这样 child 函数和 inner 函数就不存在引用关系，就无法形成闭包。 function foo(increment){ let counter = 0; function child(){ counter += increment; console.log(counter); return function inner(){ const msg = `counter is ${counter}`; console.log(msg); } } return child; } const _child = foo(1); const _inner = _child(); // 1 _child(); // 2 _child(); // 3 _inner(); // counter is 3 从下图可以看到，在运行最后的 _inner() 时，并没有形成两个 Closure（闭包）： 从上述的例子可以看出，并不是所有的函数都能形成闭包，需要子函数有父函数变量的引用才行。 实际运用防抖节流 function debounce(fn, delay = 300) { let timer; //闭包引用的外界变量 return function () { const args = arguments; if (timer) { clearTimeout(timer); } timer = setTimeout(() => { fn.apply(this, args); }, delay); }; }","link":"/post/829cdca1/"},{"title":"JS基础 - Object 对象","text":"整理一下在日常开发中会用到的 Object 的 API Object.assign()用途： 将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象。 语法： Object.assign(target, ...sources) 示例： const target = { a: 1, b: 2 }; const source = { b: 4, c: 5 }; const returnedTarget = Object.assign(target, source); console.log(target); // output: { a: 1, b: 4, c: 5 } console.log(returnedTarget); // output: { a: 1, b: 4, c: 5 } 注意点： Object.assign() 方法创建的对象是原对象的浅拷贝。 Object.create()用途： 创造一个新对象，使用现有的对象来提供新创建的对象的原型（ __proto__） ，常用来实现寄生式继承 语法： Object.create(proto，[propertiesObject]) 示例： const target = { a: 1 }; const returnedTarget = Object.create(target); console.log(returnedTarget.__proto__); // output: { a: 1 } Object.defineProperty()用途： 直接在一个对象上定义一个新属性，或者修改一个对象的属性，并返回此对象。和直接定义属性的区别在于：提供了更多的配置项。 语法： Object.defineProperty(obj, prop, descriptor) obj：需要被创建/修改属性的对象 prop：需要被修改的对象名 description：配置项 value：any，默认值为 undefined，属性值； configurable【可配置】：boolean，默认为 false，为 true 时属性可以被删除（delete）或重新设置（defineProperty），为 false 时则不可以； writable【可写入】：boolean，默认为 false，为 true 时可以被重写，为 false 则不可被重写； enumerable【可枚举】：boolean，默认值为 false，为 true 时属性可以被枚举（for…in / Object.keys()）； get：function，默认值为 undefined，访问属性时会调用该函数，函数不传入任何参数，但是会传入 this 对象。该函数的返回值会被用作属性的值。 set：function，默认值为 undefined，修改属性时会调用该函数，函数接收被赋予的新值和 this 对象。 示例： var obj = {}; Object.defineProperty(obj,\"newKey\",{ value: \"hello\", writable: true, enumerable: false }); var obj = { archive: [] }; Object.defineProperty(obj,\"newKey\",{ get: function(){ return value }, set: function(value){ obj.archive.push({ val: value }) } }); obj.newKey = 1; console.log( obj ) // output: { archive: [{ val: 1 }] } 注意点： descriptor 中 value 或 writable 不能和 get 或 set 键同时存在 Object.defineProperties()用途： 与 defineProperty 的用途一致，不过能同时新增或修改多个属性。 语法： Object.defineProperties(obj, props) 示例： var obj = {}; Object.defineProperties(obj, { 'property1': { value: true, writable: true }, 'property2': { value: 'Hello', writable: false } }); Object.entries()用途： 返回一个给定对象自身可枚举属性的键值对数组。 语法： Object.entries(obj) 示例： var obj = { a: 1, b: 2 }; Object.entries(obj); // output: [[ \"a\", 1 ],[ \"b\", 2 ]] 注意点： Object.entries() 的作用和 for…in 类似，不过 for…in 还会返回原型链中的属性。 Object.fromEntries()用途： Object.entries() 的反向操作，可将 Array 、Map 或者其他键值对列表转换为一个对象 语法： Object.fromEntries(iterable); 示例： const entries = new Map([ [ \"a\", 1 ], [ \"b\", 2 ] ]); const entries2 = [ [ \"a\", 1 ], [ \"b\", 2 ] ]; const obj1 = Object.fromEntries(entries); const obj2 = Object.fromEntries(entries2); console.log(obj); // output: { a: 1, b: 2 } console.log(obj2); // output: { a: 1, b: 2 } Object.freeze()用途： 冻结一个对象，冻结对象的属性不能新增或者修改，且不能修改已有属性的可枚举性（enumerable）、可配置性（configurable）、可写性（writable），但是如果对象的值是对象，则还是可以修改值对象里面的内容。 语法： Object.freeze(obj) 示例： const obj = { prop: 42 }; Object.freeze(obj); obj.prop = 33; // Error Object.seal()用途： 封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。 freeze 和 seal 的共同点在于：对象变得不可配置（configurable），无法添加或删除属性，不同点在于：seal 封闭对象的属性可写（writable），而 freeze 冻结对象的属性不可写。 语法： Object.seal(obj) Object.is()用途： 判断两个值是否为同一个值，和全等（===）一样，他并不会进行类型转换，具体区别如下图所示： 语法： Object.is(value1, value2); Object.keys()用途： 返回一个由一个给定对象的自身可枚举属性组成的数组。 语法： Object.keys(obj) 示例： var arr = ['a', 'b', 'c']; console.log(Object.keys(arr)); // output: [\"0\", \"1\", \"2\"] var obj = { a: 1, b: 2, c: 3 }; console.log(Object.keys(arr)); // output: [\"a\", \"b\", \"c\"] Object.values()用途： 返回一个给定对象自身的所有可枚举属性值的数组。 语法： Object.values(obj) 示例： var obj = { a: 1, b: 2, c: 3 }; console.log(Object.keys(arr)); // output: [1, 2, 3] Object.getPrototypeOf()用途： 获取指定对象的原型 语法： Object.getPrototypeOf(object) 示例： const prototype1 = {}; const object1 = Object.create(prototype1); console.log(Object.getPrototypeOf(object1) === prototype1); // output: true Object.setPrototypeOf()用途： 设置指定对象的原型，其作用和Object.create()是一样的，但是对于数据量很大的对象来说，Object.create()的性能会更好。 语法： Object.setPrototypeOf(obj, prototype) Object.getOwnPropertyNames()用途： 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组 语法： Object.getOwnPropertyNames(obj) 示例： var obj = { a: 1, b: 2, c: 3 }; Object.getOwnPropertyNames(obj); // output: [\"a\", \"b\", \"c\"] 以下为原型方法： Object.prototype.toString()用途： 返回一个表示该对象的字符串 语法： Object.setPrototypeOf(object) 示例： var obj = new Object(); obj.toString(); // output: [object Object] 注意点： toString()方法可能被覆盖，所以在调用时需要以Object.prototype.toString.call(obj)的形式来调用。 Object.prototype.valueOf()用途： 返回指定对象的原始值 不同对象的 valueOf 方法返回值 对象 返回值 Array 数组本身 Boolean Boolean Date UTC 时间 Function 函数本身 Number Number Object 对象本身 String String 语法： object.valueOf() 示例： var obj = new Object(); obj.valueOf(); // output: {} Object.prototype.hasOwnProperty()用途： 返回一个布尔值，用于表示对象自身属性中是否含有指定属性 语法： object.valueOf() 示例： var obj = { a: 1 }; obj.hasOwnProperty(\"b\"); // output: false","link":"/post/55257/"},{"title":"JS基础 - for 循环","text":"for 循环的基础知识点 for 循环的执行机制for 循环内含有三个语句 for( 语句1,语句2,语句3 ){ 自定义函数 } 第一次循环： 先执行第一个初始化语句，再执行第二个判断语句，如果判断符合则执行自定义函数，如果判断不符合则停止执行。 举个例子： for (var a = 0; a &lt; 5; a++) { console.log(a); } 上述代码的执行顺序： var a = 0; a &lt; 5 console.log(a) a++ 之后的循环： 先执行第二个判断语句，对上一次执行第三个语句的结果进行判断（这里是 js 引擎底层对值进行了记忆），如果判断符合则执行自定义函数，如果判断不符合则停止执行。 for 循环中 var 和 let 的区别for 循环中对初始化语句只会执行一次，先看个例子： const a = []; for (var i = 0; i &lt; 5; i++) { a[i] = () =>{ console.log(i) } } a[2](); // 5 根据上述的执行机制可以看出：当前 a 数组的长度是 5， i 的值为 5 当我们取 a[2] 时返回的不是 2 而是 5，说明 for 循环内的第三个语句其实都是在修改同一个变量 i 需要注意的是，上面赋给数组 a 的是一个函数，执行函数的时候才会去读取变量 i ，如果把上面的代码修改一下，直接将变量 i 赋值给数组 a，因为数字不是引用类型，所以得到的数组 a 为 [0,1,2,3,4]： const a = []; for (var i = 0; i &lt; 5; i++) { a[i] = i; } a[2]; // 2 回到最初的代码，如果把 var 替换成 let： const a = []; for (let i = 0; i &lt; 5; i++) { a[i] = () =>{ console.log(i) } } a[2](); // 2 这是能够打印出预期的结果，那么同样是执行一次初始化语句，为什么 let 能够保持 i 的值呢？是因为 Js 引擎在 for 循环到 let 初始化变量时，会生成多个块级作用域，这些块级作用域中的值互不影响，所以能够保持各自独立的值。 现在在 for 循环之后添加一个 console 语句： for (var i = 0; i &lt; 5; i++) { // whatever } console.log( i ) // 5 for (let i = 0; i &lt; 5; i++) { // whatever } console.log( i ) // ReferenceError: i is not defined 原因也很好理解：var 存在着变量提升，所以使用 var 来初始化时，后续的代码也能够访问到初始化的变量。 如果将 let 从语句1中提出来，会是什么样的： const a = []; let i = 0; for ( ;i &lt; 5; i++) { a[i] = () =>{ console.log(i) } } a[2](); // 5 因为此时 let 已经不受 for 循环的控制了，无法生成多个块级作用域，所以与 var 的效果一致。 在 for 循环中改进 var使用闭包可以让 var 声明达到与 let 一致的效果，具体的解释在《理解闭包》文章中有说明。 for (var i = 0; i &lt; 5; i++) { (function(n){ setTimeout(() => console.log(n), 1000) })(i) } // 0 1 2 3 4 for 循环遇到定时器将上面的代码稍微变动一下： for (var i = 0; i &lt; 5; i++) { setTimeout(() => console.log(i), 1000) } // 5 5 5 5 5 for (let i = 0; i &lt; 5; i++) { setTimeout(() => console.log(i), 1000) } // 0 1 2 3 4 其实和上述的原理是一致的，var 生成了一个公用的变量，而 let 生成了多个独立的块级作用域。 其它循环方法除了 for 循环外，还有 while 和 do...while方法可以实现循环，他们两者的区别就在于 while 先判断条件后执行，do…while 先执行后判断条件： do statement while (expression); // or do { statement } while (expression); 与 for 循环相比 while 循环增加了 continue 方法来中止本轮循环，但它们都可以使用 break 方法来跳出循环： var i = 0; while (i &lt; 10){ i++; if (i%2 === 0) continue; console.log(i); } // 1,3,5,7,9 for (var i = 0; i &lt; 5; i++) { console.log(i); if (i === 3) break; } // 0,1,2,3","link":"/post/2bc2490b/"},{"title":"JS基础 - 数组操作方法合集","text":"常用的处理数组的方法合集 遍历forEachforEach：对数组内的每个方法都执行一次给定的函数 语法：arr.forEach(callback(currentValue [, index [, array]])[, thisArg]) const array1 = ['a', 'b', 'c']; array1.forEach(element => console.log(element)); 可选参数可以获取到：当前的值、index、当前被循环的数组。 一个额外的参数 thisArg，可以用来指定调用回调函数时的 this 的值，举个例子： const array1 = ['a', 'b', 'c']; const obj = {a: 1}; array1.forEach(function(){ console.log(this) }, obj); //output: {a: 1} 需要注意的是：如果要正确获取 this 的值，不能用箭头函数。 map、filter 两个方法都支持修改 this 的指向。 mapmap：返回一个数组，其中每个元素都使用指定函数进行过转换。 语法： var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) const arr = [1, 2, 3, 4, 5, 6]; const mapped = arr.map(el => el + 20); console.log(mapped); // [21, 22, 23, 24, 25, 26] filterfilter：返回一个数组，只有当指定函数返回 true 时，相应的元素才会被包含在这个数组中。 语法：var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) const arr = [1, 2, 3, 4, 5, 6]; const filtered = arr.filter(el => el === 2 || el === 4); console.log(filtered); // [2, 4] 查询everyevery：测试一个数组内的所有元素是否都能通过某个指定函数的测试，返回一个布尔值。 语法：var newArray = arr.every(callback(element[, index[, array]])[, thisArg]) const array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every((currentValue) => currentValue &lt; 40)); // output: true somesome：判断数组中是否至少有一个元素通过了函数测试。 语法：arr.some(callback(element[, index[, array]])[, thisArg]) const array1 = [1, 30, 39, 29, 10, 13]; console.log(array1.every((currentValue) => currentValue &lt; 10)); // output: true findfind：返回数组中满足提供的测试函数的第一个元素的值。 语法：arr.find(callback[, thisArg]) const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; const found = arr.find(el => el > 5); console.log(found); // 6 虽然 5 之后的元素都符合条件，但只返回第一个匹配的元素。 findIndexfindIndex：返回数组中满足提供的测试函数的第一个元素的索引。 语法：arr.findIndex(callback[, thisArg]) const arr = ['Nick', 'Frank', 'Joe', 'Frank']; const foundIndex = arr.findIndex(el => el === 'Frank'); console.log(foundIndex); // 1 indexOfindexOf：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法：arr.indexOf(searchElement[, fromIndex]) fromIndex：开始查找的位置。 const arr = ['Nick', 'Frank', 'Joe', 'Frank']; const foundIndex = arr.indexOf('Frank'); console.log(foundIndex); // 1 lastIndexOflastIndexOf：返回给定元素在数组内的最后一个索引，如果不存在，则返回 -1。 语法：arr.lastIndexOf(searchElement[, fromIndex]) includesincludes：判断数组中是否包含某项，返回一个布尔值。 语法：arr.includes(valueToFind[, fromIndex]) const array1 = [1, 2, 3]; console.log(array1.includes(2)); // output: true 增删push、pop、shift、unshiftpush：这是一个相对简单的方法，它将一个项添加到数组的末尾。它就地修改数组，函数本身会返回添加到数组中的项。 let arr = [1, 2, 3, 4]; const pushed = arr.push(5); console.log(arr); // [1, 2, 3, 4, 5] console.log(pushed); // 5 pop：从数组中删除最后一项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。 let arr = [1, 2, 3, 4]; const popped = arr.pop(); console.log(arr); // [1, 2, 3] console.log(popped); // 4 shift：从数组中删除第一个项。同样，它也是就地修改数组。函数本身返回从数组中删除的项。 let arr = [1, 2, 3, 4]; const shifted = arr.shift(); console.log(arr); // [2, 3, 4] console.log(shifted); // 1 unshift：将一个或多个元素添加到数组的开头。同样，它也是就地修改数组。与其他方法不同的是，函数本身返回数组最新的长度。 let arr = [1, 2, 3, 4]; const unshifted = arr.unshift(5, 6, 7); console.log(arr); // [5, 6, 7, 1, 2, 3, 4] console.log(unshifted); // 7 splice、slicesplice：通过删除或替换现有元素或者添加新元素来修改数组的内容。这个方法也是就地修改数组。 语法：array.splice(start[, deleteCount[, item1[, item2[, ...]]]]) 下面的代码示例的意思是：在数组的位置 1 上删除 0 个元素，并插入 b。 let arr = ['a', 'c', 'd', 'e']; arr.splice(1, 0, 'b'); slice：从指定的起始位置和结束位置之前（即前闭后开）返回数组的浅拷贝。如果未指定结束位置，则返回数组的其余部分。这个方法不会修改数组，只是返回所需的子集。 语法：arr.slice([begin[, end]]) let arr = ['a', 'b', 'c', 'd', 'e', 'f']; const sliced = arr.slice(2, 4); console.log(sliced); // ['c', 'd'] console.log(arr); // ['a', 'b', 'c', 'd', 'e'] 小结一下 所有插入元素的方法，比如 push、unshift 一律返回数组新的长度； 所有删除元素的方法，比如 pop、shift、splice 一律返回删除的元素，或者返回删除的多个元素组成的数组； 格式化concatconcat：用于合并两个或多个数组，返回一个新数组。 语法：var new_array = old_array.concat(value1[, value2[, ...[, valueN]]]) const array1 = ['a', 'b', 'c']; const array2 = ['d', 'e', 'f']; const array3 = array1.concat(array2); console.log(array3); // output: Array [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"] flatflat：按照一个可指定的深度递归遍历数组，将深层次的数组进行扁平化。 语法：arr.flat([depth]) depth：数组的深度，如果不知道有多少层，可以设置为Infinity。 const arr1 = [0, 1, 2, [3, 4]]; console.log(arr1.flat()); // output: [0, 1, 2, 3, 4] const arr2 = [0, 1, 2, [[[3, 4]]]]; console.log(arr2.flat(2)); // output: [0, 1, 2, [3, 4]] fillfill：用一个固定值进行填充，可设置起止位置（不包括中止索引的位置）。 语法：arr.fill(value[, start[, end]]) [1, 2, 3].fill(4); // [4, 4, 4] [1, 2, 3].fill(4, 1); // [1, 4, 4] [1, 2, 3].fill(4, 1, 2); // [1, 4, 3] fromfrom：从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。 语法：Array.from(arrayLike[, mapFn[, thisArg]]) arrayLike：伪数组对象/可迭代对象（例如Set/Map对象、函数里面的参数对象 arguments、用 getElementsByTagName/ClassName/Name 获得的 HTMLCollection、用 querySelector 获得的 NodeList） mapFn：可选参数，如果指定了该参数，新数组中的每一项都会执行该回调函数； thisArg：可选参数，执行回调函数时的 this 对象； console.log(Array.from('foo')); // output: Array [\"f\", \"o\", \"o\"] console.log(Array.from([1, 2, 3], x => x + x)); // output: Array [2, 4, 6] const set = new Set(['foo', 'bar', 'baz', 'foo']); Array.from(set); // output: [ \"foo\", \"bar\", \"baz\" ] const map = new Map([[1, 2], [2, 4], [4, 8]]); Array.from(map); // output: [[1, 2], [2, 4], [4, 8]] reversereverse：将数组中元素的位置颠倒，该方法会修改原数组。 const array1 = ['one', 'two', 'three']; console.log('array1:', array1); // output: \"array1:\" Array [\"one\", \"two\", \"three\"] sortsort：根据提供的函数对数组进行排序。这个方法就地修改数组。如果函数返回负数或 0，则顺序保持不变。如果返回正数，则交换元素顺序。 let arr = [1, 7, 3, -1, 5, 7, 2]; const sorter = (firstEl, secondEl) => firstEl - secondEl; arr.sort(sorter); console.log(arr); // [-1, 1, 2, 3, 5, 7, 7] toStringtoString：返回一个字符串，表示指定的数组及其元素。 const array1 = [1, 2, 'a', '1a']; console.log(array1.toString()); // output: \"1,2,a,1a\" 面对嵌套数组，toString 也可以实现类似于 flat 方法的扁平化处理 [1, [2, [3, 4]]].toString(); // \"1,2,3,4\" 转换joinjoin：将一个数组（或者类数组）内的所有元素拼接成一个字符串。 语法：arr.join([separator]) const elements = ['Fire', 'Air', 'Water']; console.log(elements.join()); // output: \"Fire,Air,Water\" console.log(elements.join('')); // output: \"FireAirWater\" console.log(elements.join('-')); // output: \"Fire-Air-Water\" reducereduce：基于给定函数累加值。 语法：arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) accumulator：累计计数； currentValue：正在处理的项； const arr = [1, 2, 3, 4, 5, 6]; const reduced = arr.reduce((total, current) => total + current); console.log(reduced); // 21 keyskeys：返回一个包含数组中每个索引键的 Array Iterator 对象。 const array1 = ['a', 'b', 'c']; const iterator = array1.keys(); for (const key of iterator) { console.log(key); } // output: 0 // output: 1 // output: 2 valuesvalues：返回一个包含数组中每个索引值的 Array Iterator 对象。 const array1 = ['a', 'b', 'c']; const iterator = array1.values(); for (const value of iterator) { console.log(value); } // output: \"a\" // output: \"b\" // output: \"c\"","link":"/post/3c35ed16/"},{"title":"JS基础 - 正则","text":"正则的语法及相关 API 语法创建创建一个正则表达式对象有两种方式： 使用 new RegExp(&quot;pattern&quot;, &quot;flags&quot;)，pattern 是模式，flags 是修饰符。 例如：new RegExp('name','g') 使用斜杠语法，这种写法的缺点是他不接受变量插入 例如：/name/g 修饰符 i：不区分字母的大小写 g：查找所有匹配项 m：多行模式，只会对^和$造成影响 举个例子： let str = `1st place: Winnie 2nd place: Piglet 33rd place: Eeyore`; str.match(/^\\d+/g); // output: 1 此时并没有输出所有数字，即使 Winnie 后的字符串进行了换行，但依然将其视作一行字符串，将正则改写成/^\\d+/gm就可以正常输出结果 u：打开 unicode 支持（在 firefox 和 edge 中使用会有 bug） y：粘滞模式 相关APIregexp.test(str)用途：判断正则表达式与指定字符串是否匹配。 如果找到匹配项返回true，没有找到则返回false /\\d/.test('123') // output: true regexp.exec(str)用途：在字符串中找到匹配的字符。 如果没有找到匹配的字符，则返回null 在调用exec方法时，如果正则为全局匹配时，其返回的结果跟match方法非全局匹配下的结果一致，不过exec会维护一个lastIndex属性，当匹配到字符串时，会将lastIndex属性设置为当前匹配项的结束的位置： let reg = /\\d/g; reg.exec('123'); // output: // 0: \"1\" // groups: undefined // index: 0 // input: \"123\" console.log(reg.lastIndex); // output: 1 // 再次执行 reg.exec('123'); // output: // 0: \"2\" // groups: undefined // index: 1 // input: \"123\" console.log(reg.lastIndex); // output: 2 如果正则不是全局匹配，则会每一次都将 lastIndex 重置为 0 ，并重头开始查找： let reg = /\\d/; reg.exec('123'); console.log(reg.lastIndex); // output: 1 // 再次执行 reg.exec('123'); console.log(reg.lastIndex); // output: 1 如果在不使用全局匹配的情况向下，依然要记住上一次的 lastIndex，可以使用y修饰符： let reg = /\\d/y; reg.exec('123'); console.log(reg.lastIndex); // output: 1 // 再次执行 reg.exec('123'); console.log(reg.lastIndex); // output: 2 str.search(regexp)用途：搜索一个匹配字符，返回首次匹配到的索引，如果没有找到匹配字符，则返回-1 /\\d/.test('123') // output: 0 str.match(regexp)用途：在字符串中找到匹配的字符。 如果没有找到匹配的字符，则返回null 如果正则还有全局搜索标记g，则会返回匹配倒的字符的数组： let str = \"name=nick; first_name=john\" str.match(/name=([^;]{0,})/g) // output: [\"name=nick\", \"name=john\"] 如果不含标记g，则会返回第一个匹配项，包含其详细信息，第一项是完全匹配的内容，后几项是与捕获括号相对应的匹配字符串 let str = \"name=nick; first_name=john\" str.match(/name=([^;]{0,})/) // output: // 0: \"name=nick\" // 1: \"nick\" // groups: undefined // index: 0 // input: \"name=nick; first_name=john\" 如果使用 index 来获取匹配项不方便，可以对捕获括号进行进行命名，在捕获括号后跟上?&lt;name&gt;即可对组进行命名（要注意的是IE11不支持组命名）： let str = \"name=nick; first_name=john\" str.match(/name=(?&lt;name>[^;]{0,})/) // output: // 0: \"name=nick\" // 1: \"nick\" // groups: {name: \"nick\"} // index: 0 // input: \"name=nick; first_name=john\" str.replace(regexp, replacement)用途：在字符串中找到匹配的字符并使用新字符进行替换（生成新字符串，不会修改原字符串）。 有两种方式可以实现替换 一种方式是使用$n的方式对捕获组内的字符串进行替换： let str = \"nick john\"; str.replace(/(\\w+) (\\w+)/, '$2, $1'); // output: john,nick 另一种方式是通过组名来替换，引用方式为$&lt;name&gt;： let str = \"nick john\"; str.replace(/(?&lt;first>\\w+) (?&lt;second>\\w+)/, '$&lt;second>, $&lt;first>'); // output: john,nick 正则符号 字符 含义 \\ 转译字符常用转译：\\d：匹配一个数字，等价于[0-9]\\D：匹配一个非数字，等价于[^0-9]\\n：匹配一个换行符\\r：匹配一个回车符\\s：匹配一个空白字符\\S：\\s取反\\w：匹配一个单字字符（字母数字或者下划线，等价于[A-Za-z0-9_]）\\W：\\w取反 ^ 匹配输入的开始，当^出现在一个字符合集内时表示取反 $ 匹配输入的结尾 | 或 * 匹配前一个表达式的0次或多次，等价于{0,} + 匹配前一个表达式的1次或多次，等价于{1,} ? 匹配前一个表达式的0次或1次，等价于{0,1}，正则默认是贪婪模式，即尽可能多的匹配，加上问号后就变成了非贪婪模式 . 匹配换行符以外的所有单个字符 (x) 捕获括号，记住匹配项，它表示一个区块，例如/foo{1,2}/中{1,2}匹配的是字母o，而/(?:foo){1,2}/匹配的是整个单词foo (?:x) 非捕获括号，不记住匹配项，匹配项不会出现在 match 方法的结果数组中 x(?=y) 先行断言，foo(?=abc)表示当 foo 后面跟着 abc 时才会才会匹配 foo (?&lt;=y)x 后行断言，(?&lt;=abc)foo表示当 foo 的前面是 abc 时才会匹配 foo注意：IE 和 safari 并不支持（兼容性） x(?!y) 正向否定查找，foo(?!abc)仅当 x 后面不跟着 abc 时才会匹配 foo (?!y)x 反向否定查找，(?!abc)foo仅当 x 前面不跟着 abc 时才会匹配 foo {} 匹配次数，{n}表示前面单个字符出现了 n 次，{n,}表示前面单个字符至少出现了 n 次，{n,m}表示前面单个字符出现次数大于等于 n，小于等于 m [] 字符合集，匹配方括号中的单个任意字符，其内的特殊字符不需要转义若用-分割，则表示一个范围，/[abcd]/和/[a-d]/是一样的例如：/V[oi]la/能够匹配Vola或者Vila，单不能匹配Voila [^] 反向字符集，[^a-d]表示匹配不含 a 到 d 的字母的字符 \\b 边界，类似于^和$，当遇到\\b时会检查字符串位置是否处于边界/\\bJava\\b/表示匹配 Java 字符串，且两遍的字符不属于\\w，Hello,Java能够匹配，但Hello,Javascript无法匹配\\B表示非边界值 常用正则手机号正则 /^1[3-9]\\d{9}$/ 身份证正则 /(^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$)|(^[1-9]\\d{5}\\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\\d{3}$)/","link":"/post/62036/"},{"title":"JS基础 - 跨域","text":"跨域的概念及其解决方案 同源策略同源策略要求只有在协议、域名（及其所指向的 ip 地址）、端口都一致的站点间才可以进行： Cookie/LocalStorage/IndexDB 的读取； DOM/JS 对象的获取 发起 Ajax 请求。 以下情况属于跨域： 协议不相同：http://a.com &amp; https://a.com （主/子）域名不相同：a.com &amp; b.com；a.com &amp; www.a.com；a.com &amp; 192.168.1.1 端口不相同：a.com:8080 &amp; a.com 跨域解决方案JSONPJsonp 跨域是利用 script 标签的 src 属性来实现的，因为浏览器不会拒绝加载跨域的脚本资源，所以可以将需要传递的数据拼接写入 src url 来传给后端，后端接收到参数后，将数据包装成一个函数 A 返回给浏览器，浏览器会自动运行脚本内的函数 A 以获取数据。 举个例子： &lt;script> function handleCallback(res){ console.log(res) } &lt;/script> &lt;script src='https://a.com?id=123&amp;num=456&amp;callback=handleCallback'>&lt;/script> 后端应返回一个函数，函数名与 callback 参数值相等 handleCallback({ \"status\":\"success\",data:\"ABC\" }) 合并起来就相当于： &lt;script> function handleCallback(res){ console.log(res) } handleCallback({ \"status\":\"success\",data:\"ABC\" }) &lt;/script> 请求是异步的，所以需要异步的去创建 script 标签，将其提炼为公共方法： function jsonp({ url, data, callback }) { let scriptElement = document.createElement(\"script\"); const keysArray = Object.keys(data); const queryArray = keysArray.map(item => { return `${item}=${data[item]}`; }); scriptElement.src = `${url}?${queryArray.join(\"&amp;\")}${ queryArray.length > 0 ? \"&amp;\" : \"\" }callback=${callback}`; } jsonp({ url: \"https://a.com\", data: { id: \"123\", num: \"ABC\" }, callback: \"handleCallback\" }); CORSCORS 预检请求发生在实际请求之前，用于检查服务器是否支持 CORS，预检请求的方式是OPTIONS。 当一个请求不是“简单请求”的时候，就会发送预检请求，当满足下列一项时，就不是简单请求： 发送方式不是：GET、HEAD、POST 使用了自定义的头部字段，例如：Token 请求的 Content-Type 值不是 application/x-www-form-urlencoded 、 multipart/form-data、text/plain 那么如何才能通过预检请求完成实际请求的调用呢？ 要想实现接口的调用，就必须通过预检请求，这就需要 Http 请求头中的 Origin 字段存在于服务器返回的Access-Control-Allow-Origin字段中（如下图所示）： nginx首先要理解两个概念：正向代理和反向代理 正向代理 正向代理是一个位于客户端和原始服务器之间的代理服务器，客户端向代理服务器发送访问原始服务器的请求，代理服务器收到请求后会转交请求给原始服务器，原始服务器会将相应内容发送给代理服务器，由代理服务器转交给客户端。 正向代理服务器对于用户来说是可见的，对于原始服务器来说是透明的，因为用户必须知道正向代理的地址，才能访问到代理服务器。因为代理服务器只是做了请求的转发，所以原始服务器并不知道请求是代理服务器发出的还是客户端发出的。 正向代理的常见用途： 科学上网，访问被防火墙屏蔽的资源； 对客户端进行鉴权； 隐藏用户的身份信息和访问记录； 反向代理 反向代理和正向代理的区别在于：反向代理对于客户端来说是透明的，而对于原始服务器来说是可见的。用户不需要知道反向代理服务器的地址，请求时，用户觉得自己是在访问原始服务器，但实际上访问到的是反向代理服务器，因为原始服务器的地址不对外暴露，所有请求都会进入代理服务器，由代理服务器进行请求的转发。 反向代理的常见用途： 进行负载均衡； 隐藏服务器的真实地址； 回到跨域的问题上来，因为同源策略是浏览器的安全策略，只有在浏览器内会生效，那么假设现在有两个域名：A.com 和 B.com，在 A 域名页面内需要调用接口B.com/getCount，这时候如果能让页面内的接口A.com/proxy/b/getCount实际访问到的是接口B.com/getCount，那就通过了浏览器的同源验证。 实现上述的功能，就需要在服务端加一层反向代理，在符合匹配规则时对接口进行转发： server { listen 80; server_name A.com; location /proxy/b { proxy_pass B.com; } location / { proxy_pass A.com; } } iframe当使用 iframe 时常常会遇到如下需求： 页面和其打开的新窗口之间的消息传递 页面与嵌套的页面之间的消息传递 多窗口之间的消息传递 页面和页面间的通信需要通过 postMessage(data,origin)方法和监听message事件 data 可以为任意基本类型或可复制的对象，但是部分浏览器只支持字符串，建议先进行 JSON 序列化后传递； origin：指定可以进行通信的页面地址，格式为：协议+主机+端口号，当设置为*时表示可以传递给任意窗口，当设置为/时表示仅可以传递给与当前窗口同源的窗口 举个例子： 父页面 A.com &lt;iframe id=\"iframe\" src=\"https://B.com\" style=\"display:none;\">&lt;/iframe> &lt;script> var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { user: 'abab' }; // 向子页面发送消息 iframe.contentWindow.postMessage(JSON.stringify(data), 'https://B.com'); }; // 接收子页面消息 window.addEventListener('message', function(e) { console.log(e.data); }, false); &lt;/script> 嵌入的 iframe 子页面 B.com &lt;script> // 接收父页面消息 window.addEventListener('message', function(e) { console.log(e.data); }, false); // 子页面将消息传递给父页面 window.parent.postMessage('message from children', '/') &lt;/script>","link":"/post/7a98c92f/"},{"title":"JS笔记 - 模块化","text":"JavaScript 模块指的是一段可复用的，独立的代码。他们通常都有特定的功能，能在整个代码系统里被引进或删除。 模块通常是独立的——与其他代码解耦，因此方便修改。这也提高了代码的可读性和可维护性。模块化在使部分代码保持私有，仅暴露公共部分的的同时，还解决了命名空间模糊性的问题。 CommonJSCommonJS 规范需要使用两个关键字require和exports。 require：用来声明导入某个模块，可以传入具体的模块路径也可以传入模块名。当 require 某个模块名时，Nodejs 就会在 node_modules 文件夹中查找对应的模块； exports：用来声明当前 js 文件要导出的内容。 //------ store/customer.js 文件------ exports = function(){ return customers.get('store'); } //------ payments.js 文件------ var customerStore = require('store/customer'); Nodejs 遵守了 CommonJS 的规范，但是它使用的是module.exports。 //store/customer.js 文件 function customerStore(){ return customers.get('store'); } modules.exports = customerStore; 缺点： 只支持同步加载，不支持异步，必须等待加载完所有文件后才能运行。 只有对象能被导出（函数也是特殊的对象），即无法导出变量/常量。 CommonJS 规范不能直接在浏览器的js环境下使用 （ 必须使用 Webpack 等工具转译处理） 注意事项： require第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块。 //a.js module.exports = { name: '123', age: 27 } //b.js let obj1 = require('./a.js') console.log(obj1) // {name:'123',age:27} obj1.name = 'abc' let obj2 = require('./a.js') console.log(obj2) // {name:'abc',age:27} console.log(obj1) // {name:'abc',age:27} CommonJS模块的加载机制是，一旦输出一个值，模块内部的变化就影响不到这个值，改造了一下上面的例子，可以看到调用模块内部的 change 方法时并不会改变输出的值。 //a.js var name = \"123\"; function change() { name = \"456\"; } module.exports = { name: name, age: 27, change: change }; //b.js let obj1 = require(\"./a.js\"); console.log(obj1); // {name:'123',age:27} obj1.change(); let obj2 = require(\"./a.js\"); console.log(obj2); // {name:'123',age:27} console.log(obj1); // {name:'123',age:27} AMDAMD 解决了 CommonJS 无法直接在浏览器上使用的问题，并且支持了异步加载。 AMD 的设计初衷就是给浏览器环境使用的，可以加快页面启动时间，而且这些模块导出内容可以是对象、函数、构造器、字符串、JSON等等。支持多模块多文件。 requirejs 实现了 AMD 的规范，它使用require和defined两个 API // index.js // 调用模块 require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC){ // some code here // 可以在这里编写模块加载后的代码 }); // require()函数接受两个参数: // 第一个参数是一个数组，表示所依赖的模块['moduleA', 'moduleB', 'moduleC'] // 第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用 // 注意['moduleA', 'moduleB', 'moduleC']这里面的三个模块与index.js在同一个目录 // moduleA.js // 创建模块 define(function (){ var add = function (x,y){ return x+y; }; return { add: add }; }); // index.js require(['moduleA'], function (moduleA){ console.log(moduleA) //moduleA就是moduleA.js模块传入的函数执行后返回的对象{add：function} }); ES6ES6 模块分为两部分：export 和 import export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 此外还提供了按需加载的功能，能够动态引入模块 button.addEventListener('click', event => { import('./dialogBox.js') .then(dialogBox => { dialogBox.open(); }) .catch(error => { /* Error handling */ }) }); ES6 和 CommonJS 之间的区别： CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段","link":"/post/15812/"},{"title":"JS基础 - 判断数据类型","text":"如何准确的判断值的具体数据类型 JS 的数据类型分为基本类型和引用类型 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量；占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。 引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址，这里会涉及一个“共享”的概念；占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 基本类型：String、Number、BigInt、Boolean、Symbol、Undefined、Null 引用类型：Object Object 类型又包含：Function、Array、RegExp、Date、Math typeof若使用typeof来判断数据类型 基础类型：能够正确判断除了 Null 以外的所有基础类型； 引用类型：能够正确判断 Function 类型，其他一律返回 Object； typeof ''; // string 正确 typeof 1; // number 正确 typeof Symbol(); // symbol 正确 typeof true; // boolean 正确 typeof undefined; // undefined 正确 typeof null; // object 错误 typeof new Function(); // function 正确 typeof Function; // function 正确 typeof new Date(); // object 错误 typeof Date; // 此处是构造函数，所以返回 function typeof new RegExp(); // object 错误 typeof [] ; // object 错误 instanceofX instanceof Y 用于判断 X 是否是 Y 的实例，instanceof 无法判断基本数据类型，但是能够判断引用数据类型。 '' instanceof String; // false 2 instanceof Number; // false Symbol() instanceof Symbol; // false true instanceof Boolean; // false [] instanceof Array; // true let a = function(){}; a instanceof Function; // true let b = new Date(); b instanceof Date; // true let c = new RegExp(); c instanceof RegExp; // true toStringtoString()是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 Object.prototype.toString.call(''); // [object String] Object.prototype.toString.call(1) ; // [object Number] Object.prototype.toString.call(true); // [object Boolean] Object.prototype.toString.call(Symbol()); //[object Symbol] Object.prototype.toString.call(undefined); // [object Undefined] Object.prototype.toString.call(null); // [object Null] Object.prototype.toString.call(new Function()); // [object Function] Object.prototype.toString.call(new Date()); // [object Date] Object.prototype.toString.call([]); // [object Array] Object.prototype.toString.call(new RegExp()); // [object RegExp] Object.prototype.toString.call(new Error()); // [object Error] Object.prototype.toString.call(document); // [object HTMLDocument] Object.prototype.toString.call(window); //[object global] window 是全局对象 global 的引用","link":"/post/1f8b3fc3/"},{"title":"JS进阶 - reflow &amp; repaint 的性能优化","text":"页面的渲染过程及优化渲染方式 浏览器内核目前的 Chrome 浏览器为多进程多线程架构，包括 Browser进程、Renderer进程、GPU进程。 浏览器主进程：负责浏览器界面的显示、各个页面的管理。每次我们打开浏览器，都会启动一个主进程，结束该进程就会关闭我们的浏览器。主进程和渲染进程是分离的，这样可以保证页面的崩溃不会导致浏览器的崩溃。 渲染进程：这是网页的渲染进程，负责页面的渲染工作，一般来说，一个页面都会对应一个渲染进程，各自互相独立互不影响。 GPU 进程：如果页面启动了硬件加速，浏览器就会开启一个 GPU 进程，但是最多只能有一个，当且仅当 GPU 硬件加速打开的时候才会被创建。 每个进程都是多线程的，其目的是保持用户界面的高响应度，保证 UI 线程不会被其他操作阻碍从而影响了对用户操作的响应，例如 JS 脚本的解析执行都是在独立的线程中运行的。 页面渲染过程页面从输入 URL 到页面渲染完成，主要经历了这几个阶段： DNS 解析 建立 TCP 连接 发送 HTTP 请求 渲染页面 断开连接 DNS 解析DNS 解析的顺序依次为： 浏览器的 DNS 缓存，chrome 的缓存有效期为 60s，safari 有效期大概 10 多秒 系统缓存：hosts 文件设置的映射关系 路由器缓存 ISP（互联网服务提供商）服务器缓存 根域名服务器缓存（保存着 顶级域名服务器 的ip地址） 顶级域名服务器缓存（例如 .com 域名服务器，保存着 主域名服务器 的ip地址） 主域名服务器缓存（例如 google.com 域名服务器） 渲染页面浏览器的渲染过程如下图所示： 解析 HTML，生成 DOM 树，解析 CSS，生成 CSS 规则； 将 DOM 树和 CSS 规则结合，生成渲染树； 根据生成的渲染树进行重排（reflow），得到节点的几何信息； 根据重排获得的数据进行重绘（repaint）； 将像素发送给 GPU 进行展示； reflow 重排重排指的是浏览器重新计算文档中元素的几何信息（位置和大小）的过程。当一个元素发生重排时，他的父元素和子元素都可能发生重排。 常见的会导致重排情况： 调整浏览器窗口大小 增加或移出样式表 内容发生变化 改变字体 Js 操作 DOM 修改 style 属性的值 读取 offset、client、scroll属性或调用getComputedStyle()、getBoundingClientRect()方法 CSS 伪类激活，例如 :hover repaint 重绘当元素的样式更新时就会触发重绘，当发生 reflow 时，必定触发 repaint。 具体什么属性会触发 reflow 和 repaint 见 csstriggers 优化避免触发同步布局事件：浏览器为了防止多次重排操作引发假死，会通过队列化修改并批量执行来优化重排的过程，但如果调用 offsetTop 等属性时，浏览器为了获取到真实的值，会强制队列刷新并立即重排， 所以避免使用以下属性或方法： offsetTop/Left/Widt/Height scrollTop/Left/Width/Height clientTop/Left/Width/Height getComputedStyle() getBoundingClientRect() 如果必须使用这些属性，可以将属性值缓存起来： const width = box.offsetWidth; function initP() { for (let i = 0; i &lt; paragraphs.length; i++) { paragraphs[i].style.width = width + 'px'; } } 合并DOM操作优化重排和重绘最好的方式就是减少他们的发生次数，为此可以将多次DOM操作合并为1次： const el = document.getElementById('test'); el.style.padding = '5px'; el.style.borderLeft = '1px'; el.style.borderRight = '2px'; // 3次分离的修改触发了3次重排 // 使用cssText或class来合并修改 const el = document.getElementById('test'); el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;'; // or el.className += ' active'; 离线DOM操作如果DOM操作无法合并，可以先将DOM脱离文档流，修改完成后再带回文档中，离线DOM主要有三种方式： 使用 display:none（两次回流和重绘） function appendDataToElement(appendToElement, data) { let li; for (let i = 0; i &lt; data.length; i++) { li = document.createElement('li'); li.textContent = 'text'; appendToElement.appendChild(li); } }; const ul = document.getElementById('list'); ul.style.display = 'none'; appendDataToElement(ul, data); ul.style.display = 'block'; 使用 DocumentFragment 进行缓存操作（一次回流和重绘） const ul = document.getElementById('list'); const fragment = document.createDocumentFragment(); appendDataToElement(fragment, data); ul.appendChild(fragment); 使用 cloneNode 和 replaceChild（一次回流和重绘） const ul = document.getElementById('list'); const clone = ul.cloneNode(true); appendDataToElement(clone, data); ul.parentNode.replaceChild(clone, ul); 使用CSS硬件加速使用css3硬件加速，transform、opacity、filters等动画不会引起回流重绘","link":"/post/9e8699cf/"},{"title":"两数之和","text":"在数组中快速找到两个数，他们相加之和等于某个确定的值 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 思路循环 nums，target 减去当前项，获取到差，然后在余下的数组项里面寻找与差相等的项。 解题方案一：使用indexOf()var twoSum = function(nums, target) { for (let i = 0, len = nums.length; i &lt; len; i++) { const aim = nums.indexOf(target - nums[i], i + 1); if (aim > -1) return [i, aim]; } }; 方案二：使用 hash 表用空间换速度，通过构建一张 hash 表，可以使用键名进行查询，相对于indexOf()遍历所有元素检查，效率更高，数组长度越大，提升越明显。 var twoSum = function(nums, target) { const temp = {}; for(let i = 0, len = nums.length; i &lt; len; i++){ temp[nums[i]] = i; } for(let i = 0, len = nums.length; i &lt; len; i++){ const aim = target - nums[i]; if(temp[aim] &amp;&amp; temp[aim]!==i) return [i,temp[aim]] } }; 方案三：使用 Map（最优解）在存在大量增删操作的场景中，Map 相较于 Object 的性能更优。 var twoSum = function(nums, target) { const temp = new Map(); for (let i = 0, len = nums.length; i &lt; len; i++) { temp.set(nums[i], i); } for (let i = 0, len = nums.length; i &lt; len; i++) { const aim = target - nums[i]; if (temp.has(aim) &amp;&amp; temp.get(aim) !== i) return [i, temp.get(aim)]; } }; 不过这两种方式的结果在某些情况下的输出结果是不一样的，比如当一个数字多次出现时，因为方案一在遇到第一个符合的项时，就退出循环了，所以取到的是第一个符合的项的 index，而第二种和第三种方式使用的是 hash 表，不能存在相同的键名，相同的数字会覆盖键值（index），所以最后取到的是最后一个符合的项的 index。","link":"/post/d98ef1d2/"},{"title":"JS进阶 - 逐步实现 throttle","text":"手写 throttle 函数 用途throttle 作为节流阀，能在高频次反复调用某个方法时对调用的速率进行控制，比如：监听页面滚动时减少方法的频繁调用、提交按钮防止短时间内的多次点击。 原理每次调用 throttle 方法时，都会更新 previous 为当前的时间戳，再次调用时比较 previous 和当前时间戳（now）的差值是否大于设定的值（wait），如果差值大于 wait，则再次调用，如果差值小于 wait，则忽略，这样就实现了在一段时间内只调用一次方法 实现首先来解析一下：下面是一段常见的调用 throttle 方法的代码 document.querySelector('#btn').addEventListener( \"click\", _throttle(function(){ console.count(); }, 2000) ); 在触发点击事件的回调函数时，可以看做是：_throttle(callback).call(event.target, event)，很明显，_throttle(callback)需要返回一个函数，那么就可以形成闭包，有了闭包上一次的触发时间戳就能够被记录下来，以下代码实现了 throttle 的基本功能 &lt;button id=\"btn\">click me&lt;/button> &lt;script> function _throttle(func, wait){ // 初始化时间戳 let previous = 0; // 返回 function，且引用了父函数的变量，形成了闭包 return function() { const now = Date.now(); // 如果本次和上次的时间戳差值大于 wait 的值，则执行方法 if (now - previous > wait) { // 记录当前时间戳 previous = now; // 将回调函数指向调用 throttle 方法的 this，并传入参数 // 如果这里不绑定 this，那么 this 不会指向调用他的函数，而会指向全局对象 Window return func.apply(this, arguments); } }; }; // 对按钮设置监听 document.querySelector('#btn').addEventListener( \"click\", _throttle(function(){ console.count(); }, 2000) ); &lt;/script> 进阶underscorejs 的 throttle 方法提供了更多的选项：启用/禁用前边界调用或后边界调用。 可禁用前边界调用默认情况下，前边界调用是开启的（leading：true），首次调用时会立即执行函数，此时 previous 的值为 0，所。如果禁用了前边界调用，首次调用将不会执行，实现也很简单，只需要在初始化时，将 0 改为当前时间戳即可。（有备注的地方为新增的代码） function _throttle(func, wait, options = {}){ let context, args, result; let previous = 0; return function() { const now = Date.now(); // leading 默认是 undefined ，这里使用全等，即只有在手动传入 false 时才会禁用前边界调用 if (!previous &amp;&amp; options.leading === false) { previous = now; } args = arguments; context = this; if (now - previous > wait) { previous = now; result = func.apply(context, args); context = args = null; } return result; }; }; const btnElement = document.querySelector(\"#btn\"); btnElement.addEventListener( \"click\", _throttle( function(){ console.count(); }, 2000, { leading: false } ) ); 可启用后边界调用默认情况下，后边界调用是被禁用的（trailing：false），wait 的值为 1 时，一秒内点击三次按钮只会触发一次调用，但如果想让最后一次点击也在下一次可执行时生效，就可以使用后边界调用。 其原理就是设置定时器，在下一次可执行时再次执行函数，代码和 function 中的类似，只不过 previous 就不一定是当前时间戳了，因为要考虑到下一次调用时，如果是启用了前边界调用，则需要立即触发，如果这时候 previous 是当前时间戳，两数相减有可能小于 wait ，那就不能立即执行了，所以需要对 leading 的值进行判断 function _throttle(func, wait, options = {}){ let context, args, result; let timeout = null; let previous = 0; return function() { const now = Date.now(); if (!previous &amp;&amp; options.leading === false) { previous = now; } args = arguments; context = this; // 计算当前到下一次可触发时的时间间隔 // 因为时间可能被调整，所以这里取差值的绝对值 const remaining = wait - Math.abs(now - previous); if (remaining &lt;= 0) { if (timeout) { clearTimeout(timeout); timeout = null; } result = func.apply(context, args); previous = now; context = args = null; } else if (!timeout &amp;&amp; options.trailing === true) { timeout = setTimeout(() => { // 增加对 leading 的判断 previous = options.leading === false ? now : 0; timeout = null; result = func.apply(context, args); context = args = null; }, remaining); } return result; }; }; const btnElement = document.querySelector(\"#btn\"); btnElement.addEventListener( \"click\", _throttle( function(){ console.count(); }, 2000, { trailing: true } ) ); 与 underscore 比较来看 underscore 的 throttle 代码： _.throttle = function(func, wait, options) { var timeout, context, args, result; var previous = 0; if (!options) options = {}; var later = function() { previous = options.leading === false ? 0 : _.now(); timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; var throttled = function() { var now = _.now(); if (!previous &amp;&amp; options.leading === false) previous = now; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining > wait) { if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout &amp;&amp; options.trailing !== false) { timeout = setTimeout(later, remaining); } return result; }; throttled.cancel = function() { clearTimeout(timeout); previous = 0; timeout = context = args = null; }; return throttled; }; 有几点不同的是： underscore 没有取now - previous的绝对值，而是在remaining &gt; wait时一律允许触发操作。 在控制后边界执行的函数中（underscore 将它写在 later 方法中），将 timeout 设置为 null，但又在后面判断了一次 timeout 是否存在，多数的说法是为了防止 func 在执行期间有新的 timeout 被设置，如果 timeout 被清空了，代表不再有等待执行的 func，也清空 context 和 args，不过没有看到具体的例子。 增加了 cancel 方法，可以途中取消节流阀 完整代码function _throttle(func, wait, options = {}){ let context, args, result; let timeout = null; let previous = 0; const throttled = function() { const now = Date.now(); if (!previous &amp;&amp; options.leading === false) { previous = now; } args = arguments; context = this; const remaining = wait - Math.abs(now - previous); if (remaining &lt;= 0) { if (timeout) { clearTimeout(timeout); timeout = null; } result = func.apply(context, args); previous = now; context = args = null; } else if (!timeout &amp;&amp; options.trailing === true) { timeout = setTimeout(() => { previous = options.leading === false ? now : 0; timeout = null; result = func.apply(context, args); if(!timeout){ context = args = null; } }, remaining); } return result; }; throttled.cancel = function() { clearTimeout(timeout); previous = 0; timeout = context = args = null; }; return throttled };","link":"/post/ec9e4646/"},{"title":"数组去重","text":"对数组进行去重的多种方式 数组去重的两种思路： 对原数组进行循环，如果输出数组内没有该元素则追加至输出数组。 使用ES6的新数组结构，利用语法自身键不可重复的特性实现去重。 map 循环去重function unique(arr){ // 如果不是数组则直接返回 if(!Array.isArray(arr)) return; const outputArr = []; // 循环输入数组，如果输出数组中没有该元素，则追加至输出数组内 arr.map( (item,index)=>{ if( outputArr.indexOf(item) === -1 ){ outputArr.push( item ) } }); return outputArr; } filter 循环去重function unique(arr){ if(!Array.isArray(arr)) return; return arr.filter((item,index,arr)=>{ // 获取元素在数组中第一次出现的位置，如果和自身index相同，则返回 true return arr.indexOf(item,0) === index; }) } Set 去重ES6 提供了新的数据结构 Set，类似于数组，但是成员不得为重复的值 function unique(arr){ return [...new Set(arr)]; }","link":"/post/908d091d/"},{"title":"数组洗牌","text":"洗牌算法：将数组内的元素随机排序 原理循环数组，每次在数组中随机选取一个元素，将该元素与数组的最后一个元素进行位置的交换，在不借助其他变量的前提下实现数组的重新排序。 实现function shuffle(_array){ let n = _array.length; // 当循环至0时，退出循环 while(n){ // Math.random()*n 即可获取大于等于0且小于n的随机数 // n-- 后置递减，运行完本条语句后才会减1 const t = Math.floor( Math.random() * n-- ); // 当前随机选中的元素会依次和倒数第1、2...的元素进行位置的交换 // 使用ES6的解构赋值，交换两者的位置 [ _array[n],_array[t] ] = [ _array[t],_array[n] ]; } return _array; } 优化上面的代码是对数组内的所有元素进行洗牌，当数组很大，需要获取的随机数又很少的时候（例如抽奖），可以只进行部分洗牌，通过修改while条件来实现。 // _num：需要获取的随机元素个数 function shuffle(_array,_num){ const ns = _array.length; let n = _array.length; while( ns - n&lt;_num ){ const t = Math.floor( Math.random() * n-- ); [ _array[n],_array[t] ] = [ _array[t],_array[n] ]; } // 只返回指定数量的随机元素 return _array.slice(-_num); } 如果需要多次调用shuffle函数，且每次返回不得重复，可以将slice()替换为splice()。","link":"/post/f476fb00/"},{"title":"整数翻转","text":"将一个数字里的所有字符进行顺序的翻转 题目给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行翻转。 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 示例: 输入: 123 输出: 321 输入: -123 输出: -321 输入: 120 输出: 21 思路反转方式： 方案一：将数字转换成字符串，字符串转数组，然后进行反转，再将数组转字符串。 方案二：使用取余的方式，依次去除各位数字，然后进行拼接。 检查溢出：使用Math.pow()计算具体数值，然后进行比较。 解题方案一：使用字符串反转var reverse = function(x) { const xString = Math.abs(x) .toString() .split('') .reverse() .join(''); const xNumber = parseInt(xString); if (xNumber &lt; Math.pow(2, 31) * -1 || xNumber > Math.pow(2, 31) - 1) return 0; return x &lt; 0 ? xNumber * -1 : xNumber; }; 方案二：使用取余var reverse = function(x) { let newX = Math.abs(x); let xString = ''; while (newX > 0) { xString += newX % 10; newX = parseInt(newX / 10); } const xNumber = xString ? parseInt(xString) : 0; if (xNumber &lt; Math.pow(2, 31) * -1 || xNumber > Math.pow(2, 31) - 1) return 0; return x &lt; 0 ? xNumber * -1 : xNumber; };","link":"/post/8746d82c/"},{"title":"最长公共前缀","text":"获取到数组内的所有值的公共部分 题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例： 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 思路反转方式： 方案一：将第一个字符串设为公共字符串转换为数组，将所有字符串进行循环转换成数组，然后按顺序进行比较，如果不相等，则在公共字符串中剔除当前及之后的字符串。 方案二：将第一个字符串设为公共字符串，使用 indexOf 判断后面的每一项是否存在于公共字符串内，若没有则剔除最后一个字符串，以此类推。 解题方案一：转换成数组进行比较var longestCommonPrefix = function(strs) { if (strs.length &lt;= 0) return \"\"; let common = strs[0].split(\"\"); strs.map(item => { const current = item.split(\"\"); const currentLen = current.length; // 如果当前项的位数小于公共部分，则裁剪公共部分 if (currentLen &lt; common.length) { common = common.slice(0, currentLen); } for (let i = 0; i &lt; currentLen; i++) { if (current[i] !== common[i]) { common = common.slice(0, i); break; } } }); return common.join(\",\").replace(/,/g, \"\"); }; 方案二：使用 indexOf 进行比较var longestCommonPrefix = function(strs) { if (strs.length &lt;= 0) return \"\"; let common = strs[0]; for (let i = 1; i &lt; strs.length; i++) { while (strs[i].indexOf(common) !== 0) { common = common.substring(0, common.length - 1); } } return common; };","link":"/post/bb801601/"},{"title":"JS进阶 - 实现深拷贝","text":"实现 JS 变量的深拷贝 铺垫首先来了解一下 JS 中的变量赋值。 基本数据类型，其变量的值是存放在栈内存中的，赋值操作就是直接拷贝； var a = 3; var b = a; b++; console.log(a); // return 3; console.log(b); // return 4; 引用类型，因为值存放于堆内存中，赋值操作其实是拷贝对内存的引用； var arr = [1,2,3]; var brr = arr; brr.push(4); console.log(arr); // return [1,2,3,4] console.log(brr); // return [1,2,3,4] 不过需要注意的一点就是，如果对参数直接进行赋值操作，并不会修改参数的引用地址，但如果对参数的值进行修改，那么会影响参数的值： var a = [1,2,3]; function foo(x){ x = [3,2,1]; x.push(4); }; foo(a); console.log(a); // [1,2,3] var a = [1,2,3]; function foo(x){ x.push(4); }; foo(a); console.log(a); // [1,2,3,4] 原理对于基本数据类型来说，没有浅拷贝和深拷贝的区别； 对于引用类型来说，需要将其一步步拆解成基本数据类型进行拷贝； 如此循环，就形成了深拷贝。 基础实现对传入的对象的属性进行循环，依次加到新创建的对象中 function deepClone(source) { const target = {}; for (let key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } return target; } // 测试用例 const test = { a: 1, b: { c: 2, d: 3 } } const instance = deepClone(test); test.a = 4; test.b.c = 5; console.log(instance.a); // 1 console.log(instance.b.c); // 5 缺点： 没有对传入的数据类型进行判断，对于基础数据类型可以直接返回。 没有对对象进行深度遍历，对象嵌套对象时，还是会出现浅拷贝。 这里要区分三个方法：for...in、Object.keys()、Object.getOwnPropertyNames() for...in：会循环出除了 Symbol 以外的可枚举属性，属性中可能含有来自原型的属性，所以上述代码中用hasOwnProperty判断是否是对象本身的属性； Object.keys()：循环出自身所有可枚举属性，相当于 for…in 和 hasOwnProperty 判断的结合； Object.getOwnPropertyNames()：循环出自身的所有属性（不考虑可枚举属性）； 增加判断function deepClone(source) { // 如果 source 为 null/undefined 或者 source 不是引用类型，则直接返回 if (!source || typeof source !== \"object\") { return source; } const target = {}; Object.keys(source).forEach(function(key){ if (typeof source[key] === \"object\") { target[key] = deepClone(source[key]); } else { target[key] = source[key]; } }) return target; } // 测试用例 const test = { a: 1, b: { c: 2, d: new RegExp(\"abc\"), e: [1,2,3] } }; const instance = deepClone(test); test.a = 4; test.b.c = 5; test.b.e[0] = 4; console.log(instance.a); // 1 console.log(instance.b.c); // 2 console.log(instance.b.d); // {} console.log(instance.b.e); // {0:1,1:2,2:3} 从输出可以看到： 因为正则是特殊的对象，所以他会被再次遍历，然而这是不正确的，所以需要对typeof X === 'object'的情况进行再次的判断，剔除那些特殊的对象； 对于数组类型，需要进行特殊处理； 处理特殊对象function cloneRegExp(source) { const pattern = source.valueOf(); let flags = \"\"; flags += pattern.global ? \"g\" : \"\"; flags += pattern.ignoreCase ? \"i\" : \"\"; flags += pattern.multiline ? \"m\" : \"\"; return new RegExp(pattern.source, flags); } function deepClone(source) { if (!source || typeof source !== \"object\") { return source; } const target = Array.isArray(source) ? [] : {}; // 判断当前是否为数组类型 Object.keys(source).forEach(function(key){ if (typeof source[key] === \"object\") { switch (Object.prototype.toString.call(source[key])) { case \"[object Date]\": target[key] = new Date(source[key].valueOf()); break; case \"[object RegExp]\": target[key] = cloneRegExp(source[key]); break; default: target[key] = deepClone(source[key]); break; } } else { target[key] = source[key]; } } return target; } // 测试用例 const test = { a: new Date(), b: new RegExp(\"abc\") }; const instance = deepClone(test); console.log(instance.a); // Sun Mar 01 2020 16:19:10 GMT+0800 (中国标准时间) console.log(instance.b); // /abc/ 上面的代码基本解决了对象类型的问题，不过存在循环调用的问题，举个例子： let a = {}; a.a = a; 如果直接拷贝的话，会出现递归爆栈的情况。 解决循环调用要解决爆栈的问题，可以使用哈希表，将出现的每个对象都存储在哈希表中，拷贝的时候先查询需要拷贝的对象是否存在表中，如果存在直接取出值返回即可。 哈希表使用 ES6 的 WeakMap 实现： function cloneRegExp(source) { const pattern = source.valueOf(); let flags = \"\"; flags += pattern.global ? \"g\" : \"\"; flags += pattern.ignoreCase ? \"i\" : \"\"; flags += pattern.multiline ? \"m\" : \"\"; return new RegExp(pattern.source, flags); } function deepClone(source, hashMap = new WeakMap()) { if (!source || typeof source !== \"object\") { return source; } if (hashMap.has(source)) return hashMap.get(source); // 判断表中是否存在该对象 const target = Array.isArray(source) ? [] : {}; hashMap.set(source, target); // 设置对象 Object.keys(source).forEach(function(key){ if (typeof source[key] === \"object\") { switch (Object.prototype.toString.call(source[key])) { case \"[object Date]\": target[key] = new Date(source[key].valueOf()); break; case \"[object RegExp]\": target[key] = cloneRegExp(source[key]); break; default: // 递归时传入当前哈希表 target[key] = deepClone(source[key], hashMap); break; } } else { target[key] = source[key]; } } return target; }","link":"/post/e40f45b4/"},{"title":"JS基础 - 判断 this 的指向","text":"this 是继承自父级的执行上下文，且 JS 中 this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁（箭头函数除外），实际上 this 的最终指向的是那个调用它的对象 直接调用直接调用是指通过函数名()的方式调用。 function f(){ let a = 'A'; console.log(this.a); // undefined console.log(this); // Window } f(); 这里的 fn() 实际上是在全局对象上调用，即 Window.fn() ，所以 this 指向的是 Window。 将例子复杂化： const f = { name : \" A \", showThis: function(){ console.log(this); // Object f function bar(){ console.log(this) }; // Window bar(); // 此处相当于 Window.bar() } } f.showThis(); 方法调用方法调用是指通过对象来调用其方法函数。 const o = { a: 'A', b: function(){ console.log(this.a); } } o.b(); // A 这里是 o 在调用 b() ，所以 this 指向的是 o ，所以就取到了 A 。 如果是多层嵌套会是什么样呢？ 结论：不论嵌套了多少层，都指向最近的调用函数的对象，看个例子： const o = { a: 'A', b: { a: 'A2', c:function(){ console.log(this.a); } } } o.b.c(); // A2 最近的调用函数的对象内没有需要的变量 a，那么会会逐级向上查找吗？ 结论：会返回 undefined，this 的指向只会指向他的上一级对象，即使上上一级对象内有需要的东西。 将上面的例子改一下，删除 b 内部的 a： const o = { a: 'A', b: { c:function(){ console.log(this.a); } } } o.b.c(); // undefined 此外还有一种特殊情况，是直接调用和方法调用的混合： const o = { a: 'A', b: { a: 'A2', c:function(){ console.log(this.a); } } } const f = o.b.c; f(); // undefined 看起来是方法调用，但最后调用 fn() 时是直接调用，Window 中没有定义 a ，所以返回 undefined。 立即执行函数立即执行函数，立即执行函数不管是在全局定义还是在函数内定义，this 都指向 Window。 Window.a = 5; (function(){ console.log(this.a) })(); // 5，此时 this === Window 箭头函数箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。且这个指向在定义的时候就已经确定了，并不会在调用时指向其执行环境的对象，所以 call、apply 和 bind 方法并不能对箭头函数起作用。 var x=11; let obj={ x:22, say:()=>{ console.log(this.x); } } obj.say(); // 11 上述代码中，箭头函数里面的 this 向外寻找外层函数，但 obj 不是个函数也没有外层函数包裹，所以 this 最终指向了 Window。 需要注意的是：如果这里的 var 替换成 let，则打印出的是 undefined，因为 var 和 function 声明的全局变量是顶级对象 window 的属性，而 let / const 声明的全局变量不属于顶级对象的属性了。 如果将上面代码改造一下，在外层包裹一个自执行函数，此时 this 就指向了自执行函数： var x=11; (function(){ this.x = 33; let obj={ x:22, say:()=>{ console.log(this.x); } } obj.say(); // 33 })() 构造函数构造函数需要使用 new 关键字构建实例，通常会经历以下 4 个步骤： 创建一个对象：let newObj = {}； 将构造函数的原型赋值给新对象：Object.setPrototypeOf( newObject , foo.prototype)； 更改构造函数 this 指向新对象，然后执行构造函数的代码：foo.call( newObj )； 返回新对象； 所以使用 new 运算符构建实例时，this 会指向新生成的对象： function f(){ this.a = 'A'; } const b = new f(); console.log( b.a ) // A 在构造函数中，return 会影响 this 的指向：当 return 回来的值是对象时，那么 this 就会指向这个返回的对象，如果不是对象，则会指向原函数实例。 function f(){ this.a = 'A'; return {} } const b = new f(); console.log( b.a ) // undefined function f(){ this.a = 'A'; return 1 } const b = new f(); console.log( b.a ) // A 再来看一下类内部函数在外部调用时的场景： class Demo { constructor(x, y) { this.x = x; this.y = y; } sum() { let sumVal = this.x + this.y; return sumVal; } } let myDemo = new Demo(2, 3); const sum = myDemo.sum; // 将sum的引用赋值给新变量sum sum();// Uncaught TypeError: Cannot read properties of undefined (reading 'x') 此时的 this 还是会按照方法调用的规则，指向运行时所在的环境（Window），所以找不到对应的 x 值。 那么，如何实现 this 指向实例呢？ 可以在类的构造函数中，显式绑定 this： class Demo { constructor(x, y) { this.x = x; this.y = y; this.sum = this.sum.bind(this); // sum中this显式绑定 } sum() { let sumVal = this.x + this.y; return sumVal; } } let myDemo = new Demo(2, 3); const sum = myDemo.sum; sum(); // 5 或者使用箭头函数来申明函数： class Demo { constructor(x, y) { this.x = x; this.y = y; } sum = () => { let sumVal = this.x + this.y; return sumVal; } } let myDemo = new Demo(2, 3); const sum = myDemo.sum; sum(); // 5 修改 this 指向改变 this 指向主要有三种方法：bind、call、apply ，其中 bind 对 this 指向所造成的影响最为深远，慎用。 bind 将当前函数和对象绑定，并返回一个新的函数（注意是返回一个新函数而不是修改原函数的 this 指向），不论新函数以何种方式调用，this 始终指向绑定的对象。 const o = {}; function a(){ console.log(this === o); } const b = a.bind(o); a(); // false b(); // true 使用了 bind 后，使用 apply 或者 call 都无法再改变 this 的指向。 const o = {}; function a(){ console.log(this === o); } const b = a.bind(o); b.apply({}) b(); // true call 和 apply 的区别：传参的方式不同，call 接收若干个参数列表，而 apply 接收一个由多个参数组成的数组 func.call( thisArg , arg1 , arg2 ,… ) const foo = function (sex,address) { console.log(this.name); console.log(sex); console.log(address); } const Lucy = { name: 'lucy', } foo.call(Lucy, 'male', 'hangzhou'); // Lucy,male,hangzhou func.apply( thisArg , [ arg1 , arg2 ,… ] ) const foo = function (sex,address) { console.log(this.name); console.log(sex); console.log(address); } const Lucy = { name: 'lucy', } foo.apply(Lucy, ['male', 'hangzhou']); // Lucy,male,hangzhou 需要注意的一点是：在非严格模式下，如果传入的第一个参数为 undefined 或 null 或不传，那么 this 会默认指向 Window 对象，而在严格模式下，this 严格指向传入的第一个参数。 手写一个 call 方法承接上一个例子 const foo = function (sex,address) { console.log(this.name); console.log(sex); console.log(address); } const Lucy = { name: 'lucy', } 考虑使用 call 方法，foo 中的 this 指向调用他的对象，所以如果 foo 要获取到 this.name，就需要实现Lucy.foo()这样的调用方式，那么 foo 应该变为 Lucy 的一个属性，如下所示： const Lucy = { name: 'lucy', foo：function (sex,address) { console.log(this.name); console.log(sex); console.log(address); } } 所以 call 方法的本质就是，给 Lucy 增加一个临时属性，并在调用后删除该属性。 首先在 Function 原型链上定义一个 call2 的属性： Function.prototype.call2 = function(target,...args){} 这里不能使用箭头函数，如果是箭头函数，那么函数中的 this 就指向了全局的 window 对象，而不是 foo。 因为在调用的时候是foo.call(obj)的形式，所以 call 方法内 this 指向的是 foo 函数，这样一来就获取到了目标函数。 然后创建一个永远都不会重复的唯一键（用 Symbol 实现），foo 函数作为值： Function.prototype.call2 = function(target,...args){ const uniqueKey = Symbol(); target[uniqueKey] = this; // this 是 foo 函数 target[uniqueKey](...args); // 等同于 Lucy.foo(...args) delete target[uniqueKey]; // 删除创建的临时属性 } 这样一个简易的 call 方法就完成了。 测试用例： const foo = function (sex,address) { console.log(this.name); console.log(sex); console.log(address); } const Lucy = { name: 'lucy', } Function.prototype.call2 = function(target,...args){ const uniqueKey = Symbol(); target[uniqueKey] = this; target[uniqueKey](...args); delete target[uniqueKey]; } foo.call2(Lucy,'male','hangzhou') // lucy male hangzhou 手写一个 bind 方法bind 方法需要通过 call 方法实现，本质就是返回一个函数，然后在函数内执行 call 方法改变 this 指向。 由于返回了一个函数，在调用的时候产生了闭包，保持了对 this 的引用，解释了为什么使用 bind 后 call 和 apply 都无法再改变 this 指向。 Function.prototype.bind2 = function(target,...args){ const self = this; return function(){ self.call( target , ...args ) } } 测试用例： const foo = function (sex,address) { console.log(this.name); console.log(sex); console.log(address); } const Lucy = { name: 'lucy', } Function.prototype.bind2 = function(target,...args){ const self = this; return function(){ self.call( target , ...args ) } } foo.bind2(Lucy,'male','hangzhou')() // lucy male hangzhou","link":"/post/671ffc39/"}],"tags":[],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"文章","slug":"文章","link":"/categories/%E6%96%87%E7%AB%A0/"},{"name":"React","slug":"React","link":"/categories/React/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}